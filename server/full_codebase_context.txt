PROJECT CODEBASE CONTEXT
Generated on: 2026-01-12T06:10:02.971Z

=== FILE STRUCTURE ===
- package.json
- prisma/migrations/0_init_full_db/migration.sql
- prisma/schema.prisma
- prisma/seed.js
- prisma/seed.ts
- scripts/categorize-assets.ts
- scripts/check-cloud-sizes.ts
- scripts/check-file-sizes.ts
- scripts/enrich-tags.ts
- scripts/generate-previews.ts
- src/config/passport.ts
- src/controllers/admin.controller.ts
- src/controllers/analytics.controller.ts
- src/controllers/asset.controller.ts
- src/controllers/auth.controller.ts
- src/controllers/category.controller.ts
- src/controllers/collection.controller.ts
- src/controllers/feedback.controller.ts
- src/controllers/trash.controller.ts
- src/controllers/uploadController.ts
- src/controllers/user.controller.ts
- src/index.ts
- src/lib/prisma.ts
- src/lib/storage.ts
- src/middleware/auth.middleware.ts
- src/routes/admin.routes.ts
- src/routes/analytics.routes.ts
- src/routes/asset.routes.ts
- src/routes/auth.routes.ts
- src/routes/category.routes.ts
- src/routes/collection.routes.ts
- src/routes/feedback.routes.ts
- src/routes/uploadRoutes.ts
- src/routes/user.routes.ts
- src/scripts/ai-rename.ts
- src/scripts/backfill-thumbnails.ts
- src/scripts/check-descriptions.ts
- src/scripts/check-filenames.ts
- src/scripts/check-status.ts
- src/scripts/check-thumbnails.ts
- src/scripts/clear-chat.ts
- src/scripts/fix-and-verify.ts
- src/scripts/generate-context.ts
- src/scripts/generate-thumbnails.ts
- src/scripts/migrate-extras.ts
- src/scripts/migrate-preview-frames.ts
- src/scripts/migrate-storage.ts
- src/scripts/migrate-thumbnails.ts
- src/scripts/migrate.js
- src/scripts/migrate.ts
- src/scripts/patch-metadata.ts
- src/scripts/reset.ts
- src/scripts/spy-resource.ts
- src/scripts/verify-all.ts
- src/scripts/verify-migration.ts
- src/services/ai.service.ts
- src/services/cron.service.ts
- src/services/image.service.ts
- src/services/storage.service.ts
- src/socket/socketHandler.ts
- src/utils/supabase.ts
- tsconfig.json

======================



================================================
FILE: package.json
================================================
{
  "name": "server",
  "version": "1.0.0",
  "description": "",
  "main": "index.js",
  "scripts": {
    "start": "node dist/index.js",
    "dev": "nodemon src/index.ts",
    "build": "tsc"
  },
  "keywords": [],
  "author": "",
  "license": "ISC",
  "prisma": {
    "seed": "ts-node prisma/seed.ts"
  },
  "dependencies": {
    "@aws-sdk/client-s3": "^3.965.0",
    "@supabase/supabase-js": "^2.87.3",
    "@types/node-cron": "^3.0.11",
    "axios": "^1.13.2",
    "bcryptjs": "^3.0.3",
    "cli-progress": "^3.12.0",
    "colors": "^1.4.0",
    "cors": "^2.8.5",
    "dotenv": "^17.2.3",
    "express": "^5.1.0",
    "ffmpeg-static": "^5.3.0",
    "ffprobe-static": "^3.1.0",
    "fluent-ffmpeg": "^2.1.3",
    "fs-extra": "^11.3.2",
    "helmet": "^8.1.0",
    "jsonwebtoken": "^9.0.2",
    "multer": "^2.0.2",
    "mysql2": "^3.16.0",
    "natural": "^8.1.0",
    "node-cron": "^4.2.1",
    "openai": "^6.9.1",
    "passport": "^0.7.0",
    "passport-google-oauth20": "^2.0.0",
    "pdf-extraction": "^1.0.2",
    "sharp": "^0.34.5",
    "socket.io": "^4.8.3"
  },
  "devDependencies": {
    "@aws-sdk/lib-storage": "^3.965.0",
    "@prisma/client": "^5.22.0",
    "@types/bcryptjs": "^2.4.6",
    "@types/cli-progress": "^3.11.6",
    "@types/colors": "^1.1.3",
    "@types/cors": "^2.8.19",
    "@types/express": "^5.0.5",
    "@types/fluent-ffmpeg": "^2.1.28",
    "@types/fs-extra": "^11.0.4",
    "@types/jsonwebtoken": "^9.0.10",
    "@types/multer": "^2.0.0",
    "@types/natural": "^5.1.5",
    "@types/node": "^24.10.4",
    "@types/passport": "^1.0.17",
    "@types/passport-google-oauth20": "^2.0.17",
    "@types/pdf-parse": "^1.1.5",
    "@types/socket.io": "^3.0.1",
    "nodemon": "^3.1.11",
    "prisma": "^5.22.0",
    "ts-node": "^10.9.2",
    "typescript": "^5.9.3"
  }
}


================================================
FILE: prisma/migrations/0_init_full_db/migration.sql
================================================
-- 1. ENABLE VECTOR EXTENSION (Must be first!)
CREATE EXTENSION IF NOT EXISTS "vector";

-- 2. Create User Table
CREATE TABLE "User" (
    "id" TEXT NOT NULL,
    "email" TEXT NOT NULL,
    "password" TEXT NOT NULL,
    "name" TEXT,
    "role" TEXT NOT NULL DEFAULT 'viewer',
    "status" TEXT NOT NULL DEFAULT 'PENDING',
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" TIMESTAMP(3) NOT NULL,

    CONSTRAINT "User_pkey" PRIMARY KEY ("id")
);

-- 3. Create Asset Table (With Vector Column)
CREATE TABLE "Asset" (
    "id" TEXT NOT NULL,
    "filename" TEXT NOT NULL,
    "originalName" TEXT NOT NULL,
    "mimeType" TEXT NOT NULL,
    "size" INTEGER NOT NULL,
    "path" TEXT NOT NULL,
    "thumbnailPath" TEXT,
    "aiData" TEXT,
    "userId" TEXT NOT NULL,
    
    -- This requires the extension we enabled above
    "embedding" vector(1536),

    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" TIMESTAMP(3) NOT NULL,

    CONSTRAINT "Asset_pkey" PRIMARY KEY ("id")
);

-- 4. Create Collection Table
CREATE TABLE "Collection" (
    "id" TEXT NOT NULL,
    "name" TEXT NOT NULL,
    "slug" TEXT NOT NULL,

    CONSTRAINT "Collection_pkey" PRIMARY KEY ("id")
);

-- 5. Create AssetOnCollection Table
CREATE TABLE "AssetOnCollection" (
    "assetId" TEXT NOT NULL,
    "collectionId" TEXT NOT NULL,
    "assignedAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,

    CONSTRAINT "AssetOnCollection_pkey" PRIMARY KEY ("assetId","collectionId")
);

-- 6. Create Analytics Tables
CREATE TABLE "SearchLog" (
    "id" TEXT NOT NULL,
    "query" TEXT NOT NULL,
    "resultCount" INTEGER NOT NULL,
    "userId" TEXT,
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,

    CONSTRAINT "SearchLog_pkey" PRIMARY KEY ("id")
);

CREATE TABLE "AssetClick" (
    "id" TEXT NOT NULL,
    "assetId" TEXT NOT NULL,
    "query" TEXT NOT NULL,
    "position" INTEGER NOT NULL,
    "userId" TEXT,
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,

    CONSTRAINT "AssetClick_pkey" PRIMARY KEY ("id")
);

-- 7. Create Indexes & Foreign Keys
CREATE UNIQUE INDEX "User_email_key" ON "User"("email");
CREATE UNIQUE INDEX "Collection_slug_key" ON "Collection"("slug");

ALTER TABLE "Asset" ADD CONSTRAINT "Asset_userId_fkey" FOREIGN KEY ("userId") REFERENCES "User"("id") ON DELETE RESTRICT ON UPDATE CASCADE;
ALTER TABLE "AssetOnCollection" ADD CONSTRAINT "AssetOnCollection_assetId_fkey" FOREIGN KEY ("assetId") REFERENCES "Asset"("id") ON DELETE RESTRICT ON UPDATE CASCADE;
ALTER TABLE "AssetOnCollection" ADD CONSTRAINT "AssetOnCollection_collectionId_fkey" FOREIGN KEY ("collectionId") REFERENCES "Collection"("id") ON DELETE RESTRICT ON UPDATE CASCADE;

================================================
FILE: prisma/schema.prisma
================================================
generator client {
  provider        = "prisma-client-js"
  previewFeatures = ["postgresqlExtensions"] 
}

datasource db {
  provider  = "postgresql"
  url       = env("DATABASE_URL")
  directUrl = env("DIRECT_URL")
  extensions = [vector]
}

model User {
  id        String   @id @default(uuid())
  email     String   @unique
  password  String?  
  provider  String   @default("email") 
  name      String?
  role      String   @default("viewer") 
  status    String   @default("PENDING") 
  avatar    String?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  
  collections Collection[]
  assets      Asset[] 
  
  // ‚úÖ RELATION TO FEEDBACK
  feedbacks   Feedback[]
  messages  Message[]
  rooms    ChatRoom[] @relation("RoomMembers")

  // ‚úÖ UPDATED: Link to Membership instead of ChatRoom directly
  memberships Membership[]

  notifications Notification[]

  reactions     Reaction[]
}

// ‚úÖ FEEDBACK MODEL
model Feedback {
  id        String   @id @default(uuid())
  type      String   // 'general', 'bug', 'feature'
  subject   String
  message   String
  status    String   @default("new") 
  createdAt DateTime @default(now())

  adminReply String?   // The message from the admin
  repliedAt  DateTime? // When the reply was sent

  attachment String?

  userId    String
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  @@index([status])
}

model Category {
  id        String   @id @default(uuid())
  name      String   @unique
  group     String   
  coverImage String?
  assets    AssetOnCategory[]
  createdAt DateTime @default(now())
}

model AssetOnCategory {
  assetId    String
  categoryId String
  asset      Asset    @relation(fields: [assetId], references: [id])
  category   Category @relation(fields: [categoryId], references: [id])
  assignedAt DateTime @default(now())

  @@id([assetId, categoryId])
}

model Asset {
  id             String   @id @default(uuid())
  filename       String
  originalName   String
  mimeType       String
  size           Int
  categories     AssetOnCategory[]
  path           String    
  thumbnailPath  String?
  description    String?   
  keywords       String[]  
  legacyId       Int?      
  aiData         String?   
  embedding      Unsupported("vector(1536)")?
  uploadedBy     User      @relation(fields: [userId], references: [id])
  userId         String
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt
  collections    AssetOnCollection[]
  previewFrames String[]  @default([])

  deletedAt      DateTime?
  @@index([deletedAt])
}

model Collection {
  id        String   @id @default(uuid())
  name      String
  slug      String   @unique
  userId    String   
  owner     User     @relation(fields: [userId], references: [id])
  parentId  String?
  parent    Collection?   @relation("SubCollections", fields: [parentId], references: [id], onDelete: Cascade)
  children  Collection[]  @relation("SubCollections")
  createdAt DateTime @default(now()) 
  updatedAt DateTime @updatedAt
  assets    AssetOnCollection[]

  coverImage String?
}

model AssetOnCollection {
  asset        Asset      @relation(fields: [assetId], references: [id])
  assetId      String
  collection   Collection @relation(fields: [collectionId], references: [id])
  collectionId String
  assignedAt   DateTime   @default(now())

  @@id([assetId, collectionId])
}

model SearchLog {
  id        String   @id @default(uuid())
  query     String
  resultCount Int
  userId    String?
  createdAt DateTime @default(now())
}

model AssetClick {
  id          String   @id @default(uuid())
  assetId     String
  query       String
  position    Int      
  userId      String?
  createdAt   DateTime @default(now())
}

// ‚úÖ CHAT MODELS
model ChatRoom {
  id        String    @id @default(uuid())
  name      String
  type      String    @default("global") // 'global', 'private', 'asset'
  createdAt DateTime  @default(now())
  messages  Message[]

  // ‚úÖ UPDATED: Link to Membership instead of User directly
  memberships Membership[]

  members   User[]    @relation("RoomMembers")
}

model Message {
  id        String   @id @default(uuid())
  content   String
  
  userId    String
  user      User     @relation(fields: [userId], references: [id])
  
  roomId    String
  room      ChatRoom @relation(fields: [roomId], references: [id])
  
  createdAt DateTime @default(now())
  
  // ‚úÖ ATTACHMENT FIELDS
  attachmentUrl  String?  // Path to file in storage
  attachmentType String?  // 'image/png', 'application/pdf', etc.
  attachmentName String?  // 'project_specs.pdf' (For UI display) 

  // ‚úÖ NEW: Thread Support
  parentId      String?
  parent        Message?  @relation("Thread", fields: [parentId], references: [id], onDelete: Cascade)
  replies       Message[] @relation("Thread")

  reactions     Reaction[]  
}

// ‚úÖ NEW MODEL: The link between Users and Rooms
model Membership {
  id        String   @id @default(cuid())
  
  role      String   @default("MEMBER") // 'ADMIN', 'MEMBER'
  lastReadAt DateTime @default(now()) // <--- THE MAGIC FIELD FOR NOTIFICATIONS
  joinedAt  DateTime @default(now())

  userId    String
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  roomId    String
  room      ChatRoom @relation(fields: [roomId], references: [id], onDelete: Cascade)

  @@unique([userId, roomId]) // A user can only join a room once
}

model Reaction {
  id        String   @id @default(cuid())
  emoji     String   // The emoji character itself (e.g., "üëç")
  
  userId    String
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  messageId String
  message   Message  @relation(fields: [messageId], references: [id], onDelete: Cascade)
  
  createdAt DateTime @default(now())

  // Ensure a user can't react with the same emoji twice on the same message
  @@unique([userId, messageId, emoji])
}

// Add this new model
model Notification {
  id         String   @id @default(uuid())
  userId     String
  user       User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  text       String
  roomId     String
  roomName   String
  senderName String
  read       Boolean  @default(false)
  createdAt  DateTime @default(now())
}

================================================
FILE: prisma/seed.js
================================================
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
// server/prisma/seed.ts
const client_1 = require("@prisma/client");
const bcryptjs_1 = __importDefault(require("bcryptjs"));
const prisma = new client_1.PrismaClient();
async function main() {
    const email = 'capytech@dam.admin';
    const password = await bcryptjs_1.default.hash('Capytech2025!', 10);
    const admin = await prisma.user.upsert({
        where: { email },
        update: { status: 'ACTIVE' },
        create: {
            email,
            name: 'Admin User',
            password,
            role: 'admin',
            status: 'ACTIVE', // Set active on creation
        },
    });
    console.log({ admin });
}
main()
    .then(async () => {
    await prisma.$disconnect();
})
    .catch(async (e) => {
    console.error(e);
    await prisma.$disconnect();
    process.exit(1);
});


================================================
FILE: prisma/seed.ts
================================================
import { PrismaClient } from '@prisma/client';
import bcrypt from 'bcryptjs';

const prisma = new PrismaClient();

async function main() {
  const email = 'capytech@dam.admin';
  // üîê Securely hash the new password
  const password = await bcrypt.hash('capytech2025!', 10);

  const admin = await prisma.user.upsert({
    where: { email },
    // ‚úÖ UPDATE block: Ensures password resets even if account exists
    update: { 
        status: 'ACTIVE',
        password: password, 
        role: 'admin',
        name: 'CapyAdmin' // Updated name for branding
    },
    // ‚úÖ CREATE block: Runs only if account doesn't exist
    create: {
      email,
      name: 'CapyAdmin',
      password,
      role: 'admin',
      status: 'ACTIVE',
    },
  });

  console.log('üå± Admin account seeded:', { email: admin.email, role: admin.role });
}

main()
  .then(async () => {
    await prisma.$disconnect();
  })
  .catch(async (e) => {
    console.error(e);
    await prisma.$disconnect();
    process.exit(1);
  });

================================================
FILE: scripts/categorize-assets.ts
================================================
import { PrismaClient } from '@prisma/client';
import dotenv from 'dotenv';

// Load env vars
dotenv.config();

const prisma = new PrismaClient();

// ‚ö†Ô∏è SAFETY SWITCH: Set to false to ACTUALLY write to the database
const DRY_RUN = false; 

// üîß CONFIGURATION
const KEYWORD_MAPPING: Record<string, string[]> = {
    "Tap and Reveal": ["tap", "reveal", "interactive", "card"],
    "Buttons": ["button", "clickable", "hover"],
    "Sliders": ["slider", "drag", "range"],
    "Quizzes": ["quiz", "question", "assessment", "score"],
    "Scenarios": ["scenario", "character", "dialogue"],
    // Add more...
};

async function main() {
    console.log(`\nü§ñ Starting Asset Categorization (Explicit Relation Mode)...`);
    console.log(`üõ°Ô∏è  DRY RUN MODE: ${DRY_RUN ? "ON (No changes will be saved)" : "OFF (Database WILL be updated)"}\n`);

    // 1. Fetch all Categories
    const categories = await prisma.category.findMany();

    for (const category of categories) {
        // Determine search terms
        let searchTerms = KEYWORD_MAPPING[category.name];
        if (!searchTerms) {
            searchTerms = category.name.toLowerCase().split(' ').filter(w => w.length > 2);
        }

        if (searchTerms.length === 0) continue;

        // 2. Find assets that match keywords
        const matchingAssets = await prisma.asset.findMany({
            where: {
                // ‚úÖ FIX 1: Correct filter for Explicit Relations
                // We check if the 'categories' list does NOT have an entry for this categoryId
                categories: {
                    none: {
                        categoryId: category.id 
                    }
                },
                OR: [
                    ...searchTerms.map(term => ({
                        aiData: { contains: term, mode: 'insensitive' as const }
                    })),
                    ...searchTerms.map(term => ({
                        originalName: { contains: term, mode: 'insensitive' as const }
                    }))
                ]
            },
            select: { id: true, originalName: true }
        });

        if (matchingAssets.length > 0) {
            console.log(`üìÇ Category: "${category.name}" (Keywords: ${searchTerms.join(', ')})`);
            console.log(`   found ${matchingAssets.length} NEW assets to add.`);

            if (!DRY_RUN) {
                // ‚úÖ FIX 2: Create Join Table Records directly
                // Instead of updating the category, we bulk insert into the join table
                await prisma.assetOnCategory.createMany({
                    data: matchingAssets.map(asset => ({
                        assetId: asset.id,
                        categoryId: category.id
                    })),
                    skipDuplicates: true // Safety first!
                });
                
                console.log(`   ‚úÖ Linked ${matchingAssets.length} assets successfully.`);
            } else {
                console.log(`   Preview: ${matchingAssets.slice(0, 3).map(a => a.originalName).join(', ')}...`);
            }
            console.log('-------------------------------------------');
        }
    }

    console.log("\n‚ú® Done!");
}

main()
    .catch((e) => console.error(e))
    .finally(async () => await prisma.$disconnect());


================================================
FILE: scripts/check-cloud-sizes.ts
================================================
import { PrismaClient } from '@prisma/client';
import axios from 'axios';

const prisma = new PrismaClient();

async function checkCloudSizes() {
  console.log("‚òÅÔ∏è  Checking Supabase Thumbnail Sizes...\n");

  // Get 20 random assets that have a thumbnail
  const assets = await prisma.asset.findMany({
    where: { thumbnailPath: { startsWith: 'http' } }, // Ensure it's a URL
    take: 20,
    select: { id: true, filename: true, thumbnailPath: true }
  });

  if (assets.length === 0) {
      console.log("‚ùå No cloud thumbnails found to check.");
      return;
  }

  let heavyCount = 0;

  for (const asset of assets) {
      if (!asset.thumbnailPath) continue;

      try {
          // Send a HEAD request (gets headers only, not the body)
          const response = await axios.head(asset.thumbnailPath);
          const sizeBytes = parseInt(response.headers['content-length'] || '0', 10);
          const sizeKB = sizeBytes / 1024;

          let status = "‚úÖ OK";
          if (sizeKB > 500) {
              status = "üö® HUGE (Likely Original)";
              heavyCount++;
          } else if (sizeKB > 100) {
              status = "‚ö†Ô∏è Heavy";
              heavyCount++;
          }

          console.log(`File: ${asset.filename}`);
          console.log(`   URL:  ...${asset.thumbnailPath.slice(-30)}`);
          console.log(`   Size: ${sizeKB.toFixed(2)} KB  -> ${status}`);
          console.log('---');

      } catch (err: any) {
          console.log(`‚ùå Error checking ${asset.filename}: ${err.message}`);
      }
  }

  console.log(`\nüìä REPORT:`);
  if (heavyCount > 0) {
      console.log(`üö® Found ${heavyCount} heavy thumbnails.`);
      console.log(`   This CONFIRMS why your LCP is 33s. The thumbnails are not optimized.`);
      console.log(`   ACTION: Run the 'force-resize' script immediately.`);
  } else {
      console.log(`‚úÖ All thumbnails are optimized (<100KB). The lag is likely network/connection related.`);
  }
}

checkCloudSizes()
  .finally(async () => await prisma.$disconnect());


================================================
FILE: scripts/check-file-sizes.ts
================================================
import { PrismaClient } from '@prisma/client';
import fs from 'fs';
import path from 'path';

const prisma = new PrismaClient();

async function checkSizes() {
  console.log("‚öñÔ∏è  Weighing your thumbnails...\n");

  // Get 20 random assets with thumbnails
  const assets = await prisma.asset.findMany({
    where: { thumbnailPath: { not: null } },
    take: 20,
    select: { id: true, filename: true, thumbnailPath: true }
  });

  let hugeCount = 0;

  assets.forEach(asset => {
      if (!asset.thumbnailPath) return;

      // Construct local path (adjust if your uploads folder is different)
      // Assuming structure: server/uploads/thumbnails/file.jpg
      const localPath = path.join(__dirname, '../../uploads', asset.thumbnailPath);

      try {
          const stats = fs.statSync(localPath);
          const sizeKB = stats.size / 1024;
          
          let status = "‚úÖ OK";
          if (sizeKB > 500) {
              status = "üö® HUGE (Original?)";
              hugeCount++;
          } else if (sizeKB > 150) {
              status = "‚ö†Ô∏è Heavy";
              hugeCount++;
          }

          console.log(`File: ${asset.filename}`);
          console.log(`   Size: ${sizeKB.toFixed(2)} KB  -> ${status}`);
          console.log(`   Path: ${localPath}\n`);

      } catch (e) {
          console.log(`‚ùå Missing File: ${localPath}`);
      }
  });

  if (hugeCount > 0) {
      console.log(`\nüö® DIAGNOSIS: Found ${hugeCount} massive thumbnails.`);
      console.log("   This is the cause of your LCP (33s). We need to crush them.");
  } else {
      console.log("\n‚úÖ DIAGNOSIS: Thumbnails are small. The issue is network latency.");
  }
}

checkSizes()
  .finally(async () => await prisma.$disconnect());


================================================
FILE: scripts/enrich-tags.ts
================================================
import { PrismaClient } from '@prisma/client';
import OpenAI from 'openai';
import path from 'path';
import fs from 'fs';
import os from 'os';
import dotenv from 'dotenv';
import ffmpeg from 'fluent-ffmpeg';

// 1. Load Environment Variables
const envPath = path.resolve(__dirname, '../../.env');
dotenv.config({ path: envPath });

if (!process.env.OPENAI_API_KEY) {
    console.error("‚ùå ERROR: OPENAI_API_KEY is missing from .env");
    process.exit(1);
}

// 2. Configure FFmpeg (Auto-detect paths if needed)
// On standard Linux servers (like CS6), this usually works automatically.
// If it fails, uncomment the lines below and point to where ffmpeg is installed.
// ffmpeg.setFfmpegPath('/usr/bin/ffmpeg');
// ffmpeg.setFfprobePath('/usr/bin/ffprobe');

// 3. Initialize Clients
const prisma = new PrismaClient();
const openai = new OpenAI({
  apiKey: process.env.OPENAI_API_KEY,
  timeout: 90000, // 90s timeout (videos take longer)
});

// --- CONFIGURATION ---
const KEYWORD_THRESHOLD = 3;  
const BATCH_SIZE = 3;         // Reduced batch size (video processing is heavy)
const DELAY_MS = 2000;        

// --- HELPERS ---
const wait = (ms: number) => new Promise((resolve) => setTimeout(resolve, ms));

// Helper: Download Remote File to Temp Disk (Required for FFmpeg)
const downloadToTemp = async (url: string, ext: string): Promise<string> => {
    const tempPath = path.join(os.tmpdir(), `temp-${Date.now()}${ext}`);
    const response = await fetch(url);
    if (!response.ok) throw new Error(`Failed to fetch: ${response.statusText}`);
    const buffer = Buffer.from(await response.arrayBuffer());
    await fs.promises.writeFile(tempPath, buffer);
    return tempPath;
};

// Helper: Extract 3 Frames from Video
const extractFrames = async (videoPath: string): Promise<string[]> => {
    return new Promise((resolve, reject) => {
        const screenshots: string[] = [];
        const folder = os.tmpdir();
        const prefix = `frame-${Date.now()}`;
        
        ffmpeg(videoPath)
            .on('end', () => {
                // Return paths to the 3 generated images
                resolve([
                    path.join(folder, `${prefix}_1.jpg`),
                    path.join(folder, `${prefix}_2.jpg`),
                    path.join(folder, `${prefix}_3.jpg`)
                ]);
            })
            .on('error', (err) => reject(err))
            .screenshots({
                count: 3,           // Take 3 snapshots
                folder: folder,
                filename: `${prefix}_%i.jpg`,
                size: '640x?',      // Resize to save tokens/bandwidth
            });
    });
};

// Helper: Encode Local File to Base64
const encodeImage = async (inputPath: string): Promise<string> => {
    return (await fs.promises.readFile(inputPath)).toString('base64');
};

// --- CORE: AI ANALYSIS FUNCTIONS ---

const IMAGE_PROMPT = "Analyze this image. Return JSON: { tags: string[], description: string, educationalContext: string }";
const VIDEO_PROMPT = "Analyze these 3 keyframes from a video. Return JSON: { tags: string[], description: string, educationalContext: string }";

// 1. Analyze Image
async function analyzeImage(base64Image: string) {
    const response = await openai.chat.completions.create({
      model: "gpt-4o-mini",
      temperature: 0.4,
      messages: [
        { role: "system", content: "You are an Instructional Design Asset Analyst. Return JSON." },
        { role: "user", content: [
            { type: "text", text: IMAGE_PROMPT },
            { type: "image_url", image_url: { url: `data:image/jpeg;base64,${base64Image}` } }
        ]}
      ],
      response_format: { type: "json_object" },
    });
    return JSON.parse(response.choices[0].message.content || '{}');
}

// 2. Analyze Video (Multi-frame)
async function analyzeVideoFrames(framePaths: string[]) {
    const contentPayload: any[] = [{ type: "text", text: VIDEO_PROMPT }];
    
    // Attach all 3 frames to the prompt
    for (const framePath of framePaths) {
        if (fs.existsSync(framePath)) {
            const b64 = await encodeImage(framePath);
            contentPayload.push({ type: "image_url", image_url: { url: `data:image/jpeg;base64,${b64}` } });
        }
    }

    const response = await openai.chat.completions.create({
      model: "gpt-4o-mini",
      temperature: 0.4,
      messages: [
        { role: "system", content: "You are an Instructional Design Video Analyst. Return JSON." },
        { role: "user", content: contentPayload }
      ],
      response_format: { type: "json_object" },
    });
    return JSON.parse(response.choices[0].message.content || '{}');
}


// --- MAIN SCRIPT ---
async function main() {
  console.log('üöÄ Starting Universal AI Tag Enrichment (Images + Videos)...');

  // Count target assets
  const totalAssets = await prisma.asset.count({
      where: { 
          OR: [
              { mimeType: { startsWith: 'image/' } },
              { mimeType: { startsWith: 'video/' } }
          ]
      } 
  });
  console.log(`üìÇ Total media assets in DB: ${totalAssets}`);

  let skip = 0;
  let hasMore = true;
  let processedCount = 0;
  let updatedCount = 0;

  while (hasMore) {
    const assets = await prisma.asset.findMany({
      where: { 
          OR: [
              { mimeType: { startsWith: 'image/' } },
              { mimeType: { startsWith: 'video/' } }
          ]
      },
      take: BATCH_SIZE,
      skip: skip,
      orderBy: { createdAt: 'desc' },
    });

    if (assets.length === 0) {
      hasMore = false;
      break;
    }

    for (const asset of assets) {
      const currentKeywords = asset.keywords || [];

      // Check Threshold
      if (currentKeywords.length < KEYWORD_THRESHOLD) {
        
        console.log(`Processing: ${asset.originalName} (${asset.mimeType})...`);
        let aiResult = null;
        let tempVideoPath: string | null = null;
        let tempFrames: string[] = [];

        try {
            // --- BRANCH A: VIDEO ---
            if (asset.mimeType.startsWith('video/')) {
                const ext = path.extname(asset.filename) || '.mp4';
                
                // 1. Determine Path (Local or Remote)
                if (asset.path.startsWith('http')) {
                    console.log(`   ‚¨áÔ∏è Downloading video to temp...`);
                    tempVideoPath = await downloadToTemp(asset.path, ext);
                } else {
                    // Try to resolve local path
                    const localPath = path.resolve(__dirname, '../', asset.path);
                    if (fs.existsSync(localPath)) tempVideoPath = localPath;
                    else {
                        // Attempt one level up
                         const altPath = path.resolve(__dirname, '../../', asset.path);
                         if (fs.existsSync(altPath)) tempVideoPath = altPath;
                    }
                }

                if (!tempVideoPath || (asset.path.startsWith('http') && !fs.existsSync(tempVideoPath))) {
                    console.warn(`   ‚ö†Ô∏è Could not access video file.`);
                    continue;
                }

                // 2. Extract Frames
                console.log(`   üì∏ Extracting keyframes...`);
                tempFrames = await extractFrames(tempVideoPath);

                // 3. Analyze Frames
                console.log(`   ü§ñ Analyzing frames with AI...`);
                aiResult = await analyzeVideoFrames(tempFrames);
            } 
            
            // --- BRANCH B: IMAGE ---
            else if (asset.mimeType.startsWith('image/')) {
                let base64 = '';
                if (asset.path.startsWith('http')) {
                    const resp = await fetch(asset.path);
                    const buf = await resp.arrayBuffer();
                    base64 = Buffer.from(buf).toString('base64');
                } else {
                    const localPath = path.resolve(__dirname, '../../', asset.path); // Adjusted relative path guess
                    if (fs.existsSync(localPath)) {
                        base64 = await encodeImage(localPath);
                    } else {
                        // try fallback
                        const fallback = path.resolve(__dirname, '../', asset.path);
                         if (fs.existsSync(fallback)) base64 = await encodeImage(fallback);
                    }
                }

                if (base64) {
                    aiResult = await analyzeImage(base64);
                } else {
                    console.warn(`   ‚ö†Ô∏è Local image file missing.`);
                }
            }

            // --- SAVE RESULTS ---
            if (aiResult && aiResult.tags) {
                const combined = Array.from(new Set([...currentKeywords, ...aiResult.tags]));
                
                await prisma.asset.update({
                    where: { id: asset.id },
                    data: {
                        keywords: combined,
                        aiData: JSON.stringify(aiResult)
                    }
                });
                console.log(`   ‚úÖ Enriched! Tags: ${currentKeywords.length} -> ${combined.length}`);
                updatedCount++;
            } else {
                console.log(`   Rx No tags generated.`);
            }

        } catch (error) {
            console.error(`   ‚ùå Failed:`, error);
        } finally {
            // Cleanup Temp Files
            if (tempFrames.length > 0) {
                tempFrames.forEach(f => fs.unlink(f, () => {}));
            }
            // Only delete temp video if we downloaded it (starts with /tmp or similar logic)
            if (tempVideoPath && tempVideoPath.includes('temp-') && fs.existsSync(tempVideoPath)) {
                fs.unlink(tempVideoPath, () => {});
            }
            
            await wait(DELAY_MS);
        }
      }
    }

    skip += BATCH_SIZE;
    processedCount += assets.length;
    console.log(`--- Processed ${processedCount} assets ---`);
  }

  console.log(`\nüéâ Job Complete! Updated ${updatedCount} assets.`);
}

main()
  .catch((e) => {
    console.error(e);
    process.exit(1);
  })
  .finally(async () => {
    await prisma.$disconnect();
  });


================================================
FILE: scripts/generate-previews.ts
================================================
import { PrismaClient } from '@prisma/client';
import path from 'path';
import fs from 'fs-extra';
import axios from 'axios';
import { generateVideoPreviews } from '../src/services/image.service'; 
import { uploadToSupabase } from '../src/services/storage.service';     

const prisma = new PrismaClient();

// Helper: Download file from URL to local path
async function downloadFile(url: string, destPath: string): Promise<void> {
  const writer = fs.createWriteStream(destPath);
  const response = await axios({
    url,
    method: 'GET',
    responseType: 'stream',
  });

  response.data.pipe(writer);

  return new Promise((resolve, reject) => {
    writer.on('finish', () => resolve()); 
    writer.on('error', reject);
  });
}

async function main() {
  console.log('üé¨ Starting Video Preview Migration...');

  // 1. Find all videos
  const videos = await prisma.asset.findMany({
    where: {
      mimeType: { startsWith: 'video/' },
    },
  });

  // 2. Filter for videos that don't have previews yet
  const videosToProcess = videos.filter(v => !v.previewFrames || v.previewFrames.length === 0);

  console.log(`üîç Found ${videosToProcess.length} videos to process.`);

  // Define base temp directory
  const tempDir = path.join(__dirname, '../../uploads/temp_migration');
  await fs.ensureDir(tempDir);

  for (const video of videosToProcess) {
    console.log(`\n-----------------------------------`);
    console.log(`Processing: ${video.originalName} (ID: ${video.id})`);

    // ‚úÖ FIX: Determine full local path, including any subfolders in the filename
    const localVideoPath = path.join(tempDir, video.filename);

    try {
      // ‚úÖ FIX: Ensure the specific subdirectory exists (e.g., if filename is 'migration/video.mp4')
      await fs.ensureDir(path.dirname(localVideoPath));

      // A. Download Video
      console.log(`   ‚¨áÔ∏è Downloading to ${localVideoPath}...`);
      if (!video.path) throw new Error("No video URL found");
      
      await downloadFile(video.path, localVideoPath);

      // B. Generate Frames
      console.log(`   üì∏ Generating 10 frames...`);
      // We pass the *directory* of the local video to store frames next to it
      // But we want the output in the main tempDir to keep things simple for upload
      // So we pass 'tempDir' as the output folder, but use 'path.basename' for the file prefix
      const frameFilenames = await generateVideoPreviews(localVideoPath, tempDir, path.basename(video.filename));

      // C. Upload Frames
      console.log(`   ‚òÅÔ∏è Uploading to Supabase...`);
      const cloudFrameUrls: string[] = [];

      for (const frameFile of frameFilenames) {
        const localFramePath = path.join(tempDir, frameFile);
        
        const cloudUrl = await uploadToSupabase(
            localFramePath, 
            `previews/${frameFile}`, 
            'image/jpeg'
        );
        
        cloudFrameUrls.push(cloudUrl);
        
        // Cleanup individual frame
        await fs.remove(localFramePath); 
      }

      // D. Update Database
      console.log(`   üíæ Updating Database...`);
      await prisma.asset.update({
        where: { id: video.id },
        data: { previewFrames: cloudFrameUrls }
      });

      console.log(`   ‚úÖ Done!`);

    } catch (error) {
      console.error(`   ‚ùå Failed:`, error);
    } finally {
      // Cleanup the big video file after processing
      if (await fs.pathExists(localVideoPath)) {
        await fs.remove(localVideoPath);
      }
    }
  }

  // Final Cleanup of the entire temp directory
  await fs.remove(tempDir);
  console.log('\nüéâ Migration Complete!');
}

main()
  .catch((e) => {
    console.error(e);
    process.exit(1);
  })
  .finally(async () => {
    await prisma.$disconnect();
  });


================================================
FILE: src/config/passport.ts
================================================
import passport from 'passport';
import { Strategy as GoogleStrategy } from 'passport-google-oauth20';
import { prisma } from '../lib/prisma';

// ‚öôÔ∏è CONFIG
const COMPANY_DOMAIN = 'capytech.com'; 

const GOOGLE_CLIENT_ID = process.env.GOOGLE_CLIENT_ID;
const GOOGLE_CLIENT_SECRET = process.env.GOOGLE_CLIENT_SECRET;

// üõ°Ô∏è SAFETY CHECK: Only initialize Google Strategy if keys exist
if (GOOGLE_CLIENT_ID && GOOGLE_CLIENT_SECRET) {
  passport.use(
    new GoogleStrategy(
      {
        clientID: GOOGLE_CLIENT_ID,
        clientSecret: GOOGLE_CLIENT_SECRET,
        callbackURL: 'https://dam.capy-dev.com/api/auth/google/callback',
      },
      async (accessToken, refreshToken, profile, done) => {
        try {
          const email = profile.emails?.[0].value;

          // 1. Enforce Company Domain
          if (!email || !email.endsWith(`@${COMPANY_DOMAIN}`)) {
            return done(null, false, { message: `Only ${COMPANY_DOMAIN} emails allowed.` });
          }

          // 2. Find or Create User
          const user = await prisma.user.upsert({
            where: { email },
            update: { 
              name: profile.displayName 
            },
            create: {
              email,
              name: profile.displayName,
              password: '', 
              role: 'viewer', 
            },
          });

          return done(null, user);
        } catch (error) {
          return done(error as any, false);
        }
      }
    )
  );
} else {
  console.warn("‚ö†Ô∏è  Google SSO credentials missing in .env. SSO disabled.");
}

export default passport;

================================================
FILE: src/controllers/admin.controller.ts
================================================
import { Request, Response } from 'express';
import { prisma } from '../lib/prisma'; 

// This function fetches counts for the Admin Sidebar Badges
export const getAdminStats = async (req: Request, res: Response) => {
  try {
    // 1. Count Pending Users (Run first)
    const pendingUsers = await prisma.user.count({
      where: { status: 'PENDING' }
    });

    // 2. Count New Feedback (Run second, reusing the connection)
    const newFeedback = await prisma.feedback.count({
      where: { status: 'new' }
    });

    res.json({
      pendingUsers,
      newFeedback
    });
  } catch (error) {
    console.error('Stats error:', error);
    res.status(500).json({ message: 'Failed to fetch admin stats' });
  }
};

================================================
FILE: src/controllers/analytics.controller.ts
================================================
import { Request, Response } from 'express';
import { prisma } from '../lib/prisma';

export const getSystemAnalytics = async (req: Request, res: Response) => {
  try {
    // 1. Total Storage & Asset Count
    // Aggregates the 'size' column of all assets
    const storageStats = await prisma.asset.aggregate({
      _sum: { size: true },
      _count: { id: true }
    });

    // 2. User Stats
    const totalUsers = await prisma.user.count();
    const adminCount = await prisma.user.count({ where: { role: 'admin' } });
    const editorCount = await prisma.user.count({ where: { role: 'editor' } });

    // 3. Asset Breakdown by Type (Image, Video, Audio, Doc)
    // We fetch counts based on mimeType prefixes
    const [images, videos, audio, docs] = await Promise.all([
      prisma.asset.count({ where: { mimeType: { startsWith: 'image/' } } }),
      prisma.asset.count({ where: { mimeType: { startsWith: 'video/' } } }),
      prisma.asset.count({ where: { mimeType: { startsWith: 'audio/' } } }),
      prisma.asset.count({ where: { mimeType: { equals: 'application/pdf' } } })
    ]);

    // 4. Recent Activity (Last 5 Uploads)
    const recentUploads = await prisma.asset.findMany({
      take: 5,
      orderBy: { createdAt: 'desc' },
      select: {
        id: true,
        originalName: true,
        size: true,
        createdAt: true,
        uploadedBy: { select: { name: true } }
      }
    });

    // 5. ‚úÖ NEW: Last Active Users (Last 8 logins/updates)
    const recentUsers = await prisma.user.findMany({
      take: 8,
      orderBy: { updatedAt: 'desc' }, // Sorts by last profile update/login
      select: {
        id: true,
        name: true,
        role: true,
        email: true,
        updatedAt: true,
        avatar: true // Helpful if you want to show user icons later
      }
    });

    // Helper: Format Bytes to GB/MB
    const totalBytes = storageStats._sum.size || 0;
    
    res.json({
      storage: {
        totalBytes,
        totalAssets: storageStats._count.id,
      },
      users: {
        total: totalUsers,
        admins: adminCount,
        editors: editorCount,
        viewers: totalUsers - (adminCount + editorCount)
      },
      breakdown: {
        images,
        videos,
        audio,
        docs,
        others: storageStats._count.id - (images + videos + audio + docs)
      },
      recentActivity: recentUploads,
      recentUsers // ‚úÖ Added to response
    });

  } catch (error) {
    console.error('Analytics Error:', error);
    res.status(500).json({ message: 'Failed to fetch analytics' });
  }
};

================================================
FILE: src/controllers/asset.controller.ts
================================================
import { Request, Response } from 'express';
import { prisma } from '../lib/prisma';
import { Prisma } from '@prisma/client';
import path from 'path';
import fs from 'fs-extra';

// Import Storage Services
import { 
  uploadToSupabase, 
  deleteFromSupabase 
} from '../services/storage.service';

// Import Image Services
import { 
  generateThumbnail, 
  generateVideoThumbnail, 
  generatePdfThumbnail,
  generateVideoPreviews // ‚úÖ Required for scrubbing
} from '../services/image.service';

// Import AI Services
import { 
  analyzeImage, 
  analyzePdf, 
  analyzeAudioVideo 
} from '../services/ai.service';

interface MulterRequest extends Request {
  file?: Express.Multer.File;
  user?: any;
}

// ==========================================
// 1. UPLOAD ASSET (Synchronous Wait for AI)
// ==========================================
export const uploadAsset = async (req: Request, res: Response): Promise<void> => {
  const multerReq = req as MulterRequest;

  if (!multerReq.file) {
    res.status(400).json({ message: 'No file uploaded' });
    return;
  }

  const { filename, path: tempPath, originalname: multerOriginalName, mimetype, size } = multerReq.file;
  
  try {
    const userId = multerReq.user?.id;
    const creativity = parseFloat(req.body.creativity || '0.2'); 
    const specificity = req.body.specificity || 'general';

    // A. Capture User Inputs
    const finalOriginalName = req.body.originalName || multerOriginalName;
    
    let initialAiData = {};
    if (req.body.aiData) {
        try {
            initialAiData = JSON.parse(req.body.aiData); 
        } catch (e) {
            console.warn("Could not parse frontend aiData");
        }
    }

    // B. Setup Local Thumbnail Directory
    const thumbnailDir = path.join(__dirname, '../../uploads/thumbnails');
    await fs.ensureDir(thumbnailDir);
    
    let thumbnailRelativePath = null;
    let previewFrames: string[] = []; // ‚úÖ Store 10 frame URLs here

    // C. Generate Thumbnails & Previews (Locally)
    try {
      if (mimetype.startsWith('image/')) {
         thumbnailRelativePath = await generateThumbnail(tempPath, thumbnailDir);
      } 
      else if (mimetype.startsWith('video/')) {
         // 1. Main Thumbnail
         thumbnailRelativePath = await generateVideoThumbnail(tempPath, thumbnailDir);

         // 2. ‚úÖ Generate 10 Scrubbing Previews
         try {
             // Generate local files (e.g., vid-scrub-1.jpg ... vid-scrub-10.jpg)
             const previewFiles = await generateVideoPreviews(tempPath, thumbnailDir, filename);
             
             // Upload each frame to Supabase immediately
             for (const pFile of previewFiles) {
                 const localPPath = path.join(thumbnailDir, pFile);
                 const cloudPPath = await uploadToSupabase(
                     localPPath, 
                     `previews/${pFile}`, 
                     'image/jpeg'
                 );
                 previewFrames.push(cloudPPath);
                 await fs.remove(localPPath); // Cleanup local frame
             }
         } catch (videoError) {
             console.warn("Video preview generation failed:", videoError);
         }
      }
      else if (mimetype === 'application/pdf') {
         thumbnailRelativePath = await generatePdfThumbnail(tempPath, thumbnailDir);
      }
    } catch (thumbError) {
      console.warn("Thumbnail generation failed:", thumbError);
      thumbnailRelativePath = null;
    }

    // D. Upload ORIGINAL to Supabase
    const cloudOriginalPath = await uploadToSupabase(
      tempPath, 
      `originals/${filename}`, 
      mimetype
    );

    // E. Upload THUMBNAIL to Supabase
    let cloudThumbnailPath = null;
    if (thumbnailRelativePath) {
       const localThumbPath = path.join(__dirname, '../../uploads/', thumbnailRelativePath);
       const isWebP = thumbnailRelativePath.endsWith('.webp');
       
       cloudThumbnailPath = await uploadToSupabase(
         localThumbPath,
         thumbnailRelativePath, 
         isWebP ? 'image/webp' : 'image/jpeg'
       );
       await fs.remove(localThumbPath);
    }
    
    // F. Save to Database
    const asset = await prisma.asset.create({
      data: {
        filename,
        originalName: finalOriginalName,
        mimeType: mimetype,
        size,
        path: cloudOriginalPath,
        thumbnailPath: cloudThumbnailPath,
        previewFrames: previewFrames, // ‚úÖ Save the frames array
        userId: userId!, 
        aiData: JSON.stringify(initialAiData),
      },
    });

    // G. Trigger AI Analysis
    const aiOptions = { creativity, specificity };
    
    try {
        console.log(`ü§ñ Starting AI Analysis for ${asset.id} (${mimetype})...`);
        
        if (mimetype === 'image/gif') {
            await analyzeAudioVideo(asset.id, tempPath, aiOptions);
        } 
        else if (mimetype.startsWith('image/')) {
            await analyzeImage(asset.id, tempPath, aiOptions);
        } 
        else if (mimetype === 'application/pdf') {
            await analyzePdf(asset.id, tempPath, aiOptions);
        }
        else if (mimetype.startsWith('audio/') || mimetype.startsWith('video/')) {
            await analyzeAudioVideo(asset.id, tempPath, aiOptions);
        }
        console.log(`‚úÖ AI Analysis Finished for ${asset.id}`);
        
    } catch (err) {
        console.error("AI Analysis Warning (continuing):", err);
    } finally {
        await new Promise(resolve => setTimeout(resolve, 500));
        await fs.remove(tempPath).catch(e => console.error("Cleanup error:", e));
    }

    // H. Merge AI Data back into DB record (if frontend provided some)
    let finalAsset = await prisma.asset.findUnique({ where: { id: asset.id } });

    if (req.body.aiData && finalAsset) {
        const currentAiData = finalAsset.aiData ? JSON.parse(finalAsset.aiData) : {};
        const mergedAiData = {
            ...currentAiData,
            ...initialAiData
        };

        finalAsset = await prisma.asset.update({
            where: { id: asset.id },
            data: { aiData: JSON.stringify(mergedAiData) }
        });
    }

    res.status(201).json({
      message: 'Asset uploaded and analyzed successfully',
      asset: finalAsset || asset,
    });

  } catch (error) {
    // Emergency Cleanup
    if (await fs.pathExists(tempPath)) {
        await fs.remove(tempPath).catch(() => {});
    }
    console.error('Upload error:', error);
    res.status(500).json({ message: 'Server error processing upload' });
  }
};

// ==========================================
// 2. TRACK CLICKS (Analytics)
// ==========================================
export const trackAssetClick = async (req: Request, res: Response): Promise<void> => {
  try {
    const { assetId, query, position } = req.body;
    const userId = (req as any).user?.id;

    await prisma.assetClick.create({
      data: { assetId, query: query || '', position, userId }
    });
    res.json({ success: true });
  } catch (error) {
    res.status(500).json({ success: false });
  }
};

// ==========================================
// 3. GET ASSETS (Optimized V5.0) - with Soft Delete Support
// ==========================================
export const getAssets = async (req: Request, res: Response): Promise<void> => {
  try {
    const { search, type, color, page = 1, limit = 50 } = req.query;
    
    const pageNum = Math.max(1, Number(page));
    const limitNum = Math.max(1, Math.min(100, Number(limit))); 
    const skip = (pageNum - 1) * limitNum;

    const cleanSearch = String(search || '').trim().toLowerCase();
    
    // A. Reusable Filter Logic
    const buildFilters = () => {
        const filters: any = {
            // ‚úÖ CRITICAL: Only show assets that are NOT in the trash
            deletedAt: null
        };

        if (type && type !== 'all') {
            if (type === 'image') filters.mimeType = { startsWith: 'image/' };
            else if (type === 'video') filters.mimeType = { startsWith: 'video/' };
            else if (type === 'document') filters.mimeType = 'application/pdf';
        }
        if (color) {
            filters.aiData = { contains: String(color), mode: 'insensitive' };
        }
        return filters;
    };

    const activeFilters = buildFilters();

    // B. Lightweight Select (Include previewFrames)
    const lightweightSelect = {
        id: true,
        filename: true,
        originalName: true,
        mimeType: true,
        path: true,
        thumbnailPath: true,
        previewFrames: true, // ‚úÖ Return frames to frontend
        aiData: true, 
        uploadedBy: { select: { name: true } }
    };

    // --- MODE A: BROWSE (No Text Search) ---
    if (!cleanSearch) {
        const [total, assets] = await Promise.all([
            prisma.asset.count({ where: activeFilters }),
            prisma.asset.findMany({
                where: activeFilters,
                orderBy: { createdAt: 'desc' },
                take: limitNum,
                skip: skip,
                select: lightweightSelect, 
            })
        ]);

        const fixedAssets = assets.map(asset => ({
            ...asset,
            thumbnailPath: asset.thumbnailPath || asset.path 
        }));

        res.json({
            results: fixedAssets,
            total,
            page: pageNum,
            totalPages: Math.ceil(total / limitNum)
        });
        return;
    }

    // --- MODE B: SEARCH (Optimized) ---
    const scoredMap = new Map<string, { asset: any, score: number }>();
    let searchTerms: string[] = [cleanSearch];

    // Ensure activeFilters (including deletedAt: null) are applied to search
    const keywordWhere: any = { 
        AND: [ activeFilters ] 
    };

    if (searchTerms.length > 0) {
      keywordWhere.AND.push({
        OR: searchTerms.flatMap(term => [
          { originalName: { contains: term, mode: 'insensitive' } },
          { aiData: { contains: term, mode: 'insensitive' } },
        ])
      });
    }

    // Fetch Candidates
    const keywordAssets = await prisma.asset.findMany({
      where: keywordWhere,
      select: lightweightSelect, 
      take: 200, 
    });

    // Score Candidates
    keywordAssets.forEach(asset => {
        let score = 0;
        const lowerName = (asset.originalName || '').toLowerCase();
        const lowerAI = (String(asset.aiData) || '').toLowerCase();
        
        if (lowerName === cleanSearch) score += 100;
        else if (lowerName.includes(cleanSearch)) score += 50;
        if (lowerAI.includes(cleanSearch)) score += 30;

        scoredMap.set(asset.id, { asset, score });
    });

    let finalResults = Array.from(scoredMap.values())
        .sort((a, b) => b.score - a.score)
        .map(item => item.asset);

    const totalSearch = finalResults.length;
    const paginatedResults = finalResults.slice(skip, skip + limitNum);

    // --- MODE C: FALLBACK ---
    let isFallback = false;
    if (paginatedResults.length === 0 && pageNum === 1) {
        isFallback = true;
        const fallbackAssets = await prisma.asset.findMany({
            where: activeFilters, // Still ensures deletedAt: null
            orderBy: { createdAt: 'desc' },
            take: limitNum,
            select: lightweightSelect
        });
        
        const fixedFallback = fallbackAssets.map(asset => ({
            ...asset,
            thumbnailPath: asset.thumbnailPath || asset.path 
        }));
        
        res.json({ results: fixedFallback, isFallback: true, total: 0, page: 1, totalPages: 1 });
        return;
    }

    const fixedResults = paginatedResults.map(asset => ({
        ...asset,
        thumbnailPath: asset.thumbnailPath || asset.path 
    }));

    res.json({ 
        results: fixedResults, 
        isFallback,
        total: totalSearch,
        page: pageNum,
        totalPages: Math.ceil(totalSearch / limitNum)
    });

  } catch (error) {
    console.error("Get Assets Error:", error);
    res.status(500).json({ message: 'Error fetching assets' });
  }
};

// ==========================================
// 4. GET SINGLE ASSET
// ==========================================
export const getAssetById = async (req: Request, res: Response): Promise<void> => {
  try {
    const { id } = req.params;
    const asset = await prisma.asset.findUnique({
      where: { id },
      include: { uploadedBy: { select: { name: true, email: true } } },
    });

    if (!asset) {
      res.status(404).json({ message: 'Asset not found' });
      return;
    }
    res.json(asset);
  } catch (error) {
    res.status(500).json({ message: 'Server error' });
  }
};

// ==========================================
// 5. GET RELATED ASSETS (Recommendations)
// ==========================================
export const getRelatedAssets = async (req: Request, res: Response): Promise<void> => {
    try {
        const { id } = req.params;
        const targetAsset = await prisma.asset.findUnique({
            where: { id },
            select: { id: true, originalName: true, aiData: true, mimeType: true }
        });

        if (!targetAsset) {
            res.json([]);
            return;
        }

        let typeFilter: any = {};
        if (targetAsset.mimeType.startsWith('image/')) {
            typeFilter = { mimeType: { startsWith: 'image/' } };
        } else if (targetAsset.mimeType.startsWith('video/')) {
            typeFilter = { mimeType: { startsWith: 'video/' } };
        } else if (targetAsset.mimeType === 'application/pdf') {
            typeFilter = { mimeType: 'application/pdf' };
        }

        const stopWords = new Set(['image', 'img', 'pic', 'picture', 'photo', 'screenshot', 'screen', 'shot', 'copy', 'final', 'draft', 'upload', 'new', 'old', 'backup', 'ds', 'store', 'frame', 'rectangle', 'group', 'vector', 'untitled', 'design', 'migration', 'import', 'jpg', 'png', 'mp4']);
        
        const rawName = targetAsset.originalName || '';
        const nameKeywords = rawName.split(/[\s_\-\.\/]+/).map(w => w.toLowerCase()).filter(w => w.length > 3 && !/^\d+$/.test(w) && !stopWords.has(w));
        
        let tagKeywords: string[] = [];
        try {
            const parsed = JSON.parse(targetAsset.aiData || '{}');
            if (Array.isArray(parsed.tags)) tagKeywords = parsed.tags;
            if (typeof parsed.keywords === 'string') tagKeywords = parsed.keywords.split(',');
        } catch (e) {}

        const searchTerms = [...new Set([...tagKeywords, ...nameKeywords])].slice(0, 10);

        // Fallback: Recent items of same type
        if (searchTerms.length === 0) {
            const recent = await prisma.asset.findMany({
                where: { id: { not: id }, ...typeFilter },
                orderBy: { createdAt: 'desc' },
                take: 20,
                select: { id: true, filename: true, originalName: true, mimeType: true, thumbnailPath: true, aiData: true, previewFrames: true } 
            });
            res.json(recent);
            return;
        }

        // Search Candidates
        const candidates = await prisma.asset.findMany({
            where: { 
                id: { not: id }, 
                ...typeFilter, 
                OR: [ 
                    ...searchTerms.map(t => ({ originalName: { contains: t, mode: Prisma.QueryMode.insensitive } })), 
                    ...searchTerms.map(t => ({ aiData: { contains: t, mode: Prisma.QueryMode.insensitive } })) 
                ] 
            },
            take: 100,
            select: { id: true, filename: true, originalName: true, mimeType: true, thumbnailPath: true, aiData: true, previewFrames: true } 
        });

        // Score Candidates
        const scoredAssets = candidates.map(asset => {
            let score = 0;
            const lowerName = (asset.originalName || '').toLowerCase();
            const lowerAI = (String(asset.aiData) || '').toLowerCase();
            searchTerms.forEach(term => {
                const lowerTerm = term.toLowerCase();
                if (lowerName.includes(lowerTerm)) score += 50;
                if (lowerAI.includes(lowerTerm)) score += 30;
                if (lowerName === lowerTerm) score += 50;
            });
            return { asset, score };
        });

        const finalResults = scoredAssets.filter(item => item.score > 0).sort((a, b) => b.score - a.score).slice(0, 20).map(item => item.asset);

        // Fallback if scoring returned nothing
        if (finalResults.length === 0) {
            const recent = await prisma.asset.findMany({
                where: { id: { not: id }, ...typeFilter },
                orderBy: { createdAt: 'desc' },
                take: 20,
                select: { id: true, filename: true, originalName: true, mimeType: true, thumbnailPath: true, aiData: true, previewFrames: true }
            });
            res.json(recent);
            return;
        }
        res.json(finalResults);

    } catch (error) {
        console.error("Related Error:", error);
        res.status(500).json({ message: 'Error' });
    }
};

// ==========================================
// 6. UPDATE ASSET
// ==========================================
export const updateAsset = async (req: Request, res: Response): Promise<void> => {
  try {
    const { id } = req.params;
    const { originalName, aiData } = req.body;
    const asset = await prisma.asset.update({
      where: { id },
      data: { originalName, aiData: typeof aiData === 'object' ? JSON.stringify(aiData) : aiData },
    });
    res.json(asset);
  } catch (error) {
    console.error(error);
    res.status(500).json({ message: 'Error updating asset' });
  }
};

// ==========================================
// 7. DELETE ASSET (Soft Delete / Move to Trash)
// ==========================================
export const deleteAsset = async (req: Request, res: Response): Promise<void> => {
  try {
    const { id } = req.params;
    const userId = (req as any).user?.id;
    const userRole = (req as any).user?.role;

    console.log(`\nüóëÔ∏è [SOFT DELETE] Moving Asset ID to Trash: ${id}`);

    // 1. Find the Asset
    const asset = await prisma.asset.findUnique({ where: { id } });
    
    if (!asset) {
        res.status(404).json({ message: 'Asset not found' });
        return;
    }

    // 2. Permission Check (Owner or Admin)
    if (userRole !== 'admin' && asset.userId !== userId) {
        res.status(403).json({ message: 'Access denied' });
        return;
    }

    // 3. Perform Soft Delete (Update deletedAt)
    // We DO NOT delete files or relations yet. That happens in forceDelete.
    await prisma.asset.update({
        where: { id },
        data: { deletedAt: new Date() }
    });
    
    res.json({ message: 'Asset moved to recycle bin' });

  } catch (error) {
    console.error("üî• SOFT DELETE ERROR:", error);
    res.status(500).json({ message: 'Server error', error: String(error) });
  }
};

================================================
FILE: src/controllers/auth.controller.ts
================================================
import { Request, Response } from 'express';
import bcrypt from 'bcryptjs';
import jwt from 'jsonwebtoken';
import { prisma } from '../lib/prisma';

const JWT_SECRET = process.env.JWT_SECRET || 'fallback_secret';
const CLIENT_URL = process.env.CLIENT_URL || 'http://localhost:5173'; // ‚úÖ Defaults to local if missing

export const register = async (req: Request, res: Response): Promise<void> => {
  try {
    const { email, password, name, role } = req.body;

    // 1. Check if user exists
    const existingUser = await prisma.user.findUnique({ where: { email } });
    if (existingUser) {
      res.status(400).json({ message: 'User already exists' });
      return;
    }

    // 2. Hash password
    const hashedPassword = await bcrypt.hash(password, 10);

    // 3. Create user
    const user = await prisma.user.create({
      data: {
        email,
        password: hashedPassword,
        name,
        role: role || 'viewer', 
        status: 'PENDING', // Recommended: Default new registrations to PENDING
      },
    });

    res.status(201).json({
      message: 'User created successfully',
      user: { id: user.id, email: user.email, role: user.role },
    });
  } catch (error) {
    res.status(500).json({ message: 'Server error', error });
  }
};

export const login = async (req: Request, res: Response): Promise<void> => {
  try {
    const { email, password } = req.body;
    
    // 1. Fetch User (Including Avatar)
    const user = await prisma.user.findUnique({ where: { email } });

    if (!user) {
      res.status(400).json({ message: 'Invalid credentials' });
      return;
    }

    // --- CHECK STATUS ---
    if (user.status === 'PENDING') {
      res.status(403).json({ message: 'Account pending approval by Admin.' });
      return;
    }

    // --- üõ°Ô∏è SSO SAFETY CHECK ---
    if (!user.password) {
        res.status(400).json({ message: 'Please login with Google/SSO.' });
        return;
    }

    const isMatch = await bcrypt.compare(password, user.password);
    if (!isMatch) {
      res.status(400).json({ message: 'Invalid credentials' });
      return;
    }

    const token = jwt.sign({ id: user.id, role: user.role }, JWT_SECRET, { expiresIn: '1d' });

    // ‚úÖ FIXED RESPONSE: Now includes 'avatar'
    res.json({
      message: 'Login successful',
      token,
      user: { 
          id: user.id, 
          name: user.name, 
          email: user.email, 
          role: user.role,
          avatar: user.avatar // <--- THIS WAS MISSING!
      },
    });
  } catch (error) {
    res.status(500).json({ message: 'Server error', error });
  }
};

// PATCH /api/auth/users/:id/approve
export const approveUser = async (req: Request, res: Response): Promise<void> => {
  try {
    const { id } = req.params;
    const { role } = req.body; 

    await prisma.user.update({
      where: { id },
      data: { 
        status: 'ACTIVE',
        role: role || 'viewer' 
      },
    });

    res.json({ message: 'User approved and active' });
  } catch (error) {
    res.status(500).json({ message: 'Error approving user' });
  }
};

// DELETE /api/auth/users/:id/reject
export const rejectUser = async (req: Request, res: Response): Promise<void> => {
  try {
    const { id } = req.params;
    await prisma.user.delete({ where: { id } });
    res.json({ message: 'User request rejected and removed' });
  } catch (error) {
    res.status(500).json({ message: 'Error rejecting user' });
  }
};

// ‚úÖ SSO Callback Handler (Updated for Prod)
export const googleCallback = (req: Request, res: Response) => {
  const user = req.user as any;

  if (!user) {
    // Redirect to the Dynamic Client URL
    return res.redirect(`${CLIENT_URL}/login?error=Unauthorized`);
  }

  const token = jwt.sign(
    { id: user.id, email: user.email, role: user.role },
    JWT_SECRET,
    { expiresIn: '7d' }
  );

  // ‚úÖ Redirect to Dynamic Client URL
  res.redirect(`${CLIENT_URL}/login?token=${token}`);
};

export const getMe = async (req: Request, res: Response) => {
  try {
    const userId = (req as any).user.id;
    const user = await prisma.user.findUnique({ where: { id: userId } });
    if (!user) return res.status(404).json({ message: 'User not found' });
    
    // Handle user with no password (SSO) safely
    const { password, ...userWithoutPassword } = user;
    res.json(userWithoutPassword);
  } catch (error) {
    res.status(500).json({ message: 'Server error' });
  }
};

================================================
FILE: src/controllers/category.controller.ts
================================================
import { Request, Response } from 'express';
import { prisma } from '../lib/prisma';

// Get All Categories (Grouped)
export const getCategories = async (req: Request, res: Response) => {
  try {
    const categories = await prisma.category.findMany({
      include: { _count: { select: { assets: true } } },
      orderBy: { name: 'asc' }
    });
    res.json(categories);
  } catch (error) { res.status(500).json({ error: 'Failed to fetch categories' }); }
};

// Get Single Category with Assets
export const getCategoryById = async (req: Request, res: Response) => {
  try {
    const { id } = req.params;
    const category = await prisma.category.findUnique({
      where: { id },
      include: {
        assets: {
          include: {
            asset: { include: { uploadedBy: { select: { name: true } } } }
          }
        }
      }
    });
    if (!category) { res.status(404).json({ error: 'Category not found' }); return; }
    
    // Flatten structure
    const flatCategory = { ...category, assets: category.assets.map(a => a.asset) };
    res.json(flatCategory);
  } catch (error) { res.status(500).json({ error: 'Server error' }); }
};

// Add Asset to Category
export const addAssetToCategory = async (req: Request, res: Response) => {
  try {
    const { id } = req.params; // Category ID
    const { assetId } = req.body;
    await prisma.assetOnCategory.create({ data: { categoryId: id, assetId } });
    res.json({ success: true });
  } catch (error) { res.json({ success: true }); } // Ignore duplicates
};

// Remove Asset from Category
export const removeAssetFromCategory = async (req: Request, res: Response) => {
  try {
    const { id, assetId } = req.params;
    await prisma.assetOnCategory.deleteMany({ where: { categoryId: id, assetId } });
    res.json({ success: true });
  } catch (error) { res.status(500).json({ error: 'Failed to remove' }); }
};

// NEW: Create Category
export const createCategory = async (req: Request, res: Response): Promise<void> => {
  try {
    const { name, group } = req.body;
    
    // Check for duplicate
    const existing = await prisma.category.findUnique({ where: { name } });
    if (existing) {
        res.status(400).json({ message: 'Category already exists' });
        return;
    }

    const category = await prisma.category.create({
      data: {
        name,
        // Default to 'Inspiration' if not specified, or force user to choose
        group: group || 'Inspiration' 
      }
    });

    res.status(201).json(category);
  } catch (error) {
    console.error(error);
    res.status(500).json({ message: 'Error creating category' });
  }
};

export const deleteCategory = async (req: Request, res: Response): Promise<void> => {
  try {
    const { id } = req.params;
    
    // Optional: Check if admin/editor (Handled by middleware usually, or check user role here)
    // For now, we rely on the route protection.

    // Delete connections first (AssetOnCategory)
    await prisma.assetOnCategory.deleteMany({ where: { categoryId: id } });
    
    // Delete the category
    await prisma.category.delete({ where: { id } });

    res.json({ success: true });
  } catch (error) {
    console.error("Delete Category Error:", error);
    res.status(500).json({ message: 'Failed to delete category' });
  }
};

import { uploadToSupabase } from '../services/storage.service'; // Import this
import path from 'path';
import fs from 'fs-extra';

interface MulterRequest extends Request {
  file?: Express.Multer.File;
}

// ... existing functions ...

// 7. UPDATE CATEGORY (Rename or Change Cover)
export const updateCategory = async (req: Request, res: Response): Promise<void> => {
  const multerReq = req as MulterRequest;
  const { id } = req.params;
  const { name, group } = req.body;

  try {
    let coverImagePath = undefined;

    // Handle File Upload if present
    if (multerReq.file) {
        const { path: tempPath, filename, mimetype } = multerReq.file;
        
        // Upload to Supabase (Categories folder)
        coverImagePath = await uploadToSupabase(
            tempPath,
            `categories/${filename}`,
            mimetype
        );
        
        // Cleanup local file
        await fs.remove(tempPath);
    }

    const category = await prisma.category.update({
      where: { id },
      data: {
        ...(name && { name }),
        ...(group && { group }),
        ...(coverImagePath && { coverImage: coverImagePath }) // Only update if new file
      }
    });

    res.json(category);
  } catch (error) {
    console.error("Update Category Error:", error);
    res.status(500).json({ message: 'Failed to update category' });
  }
};

================================================
FILE: src/controllers/collection.controller.ts
================================================
import { Request, Response } from 'express';
import { prisma } from '../lib/prisma';
import { Prisma } from '@prisma/client';

// Helper to generate slug
const slugify = (text: string) => {
  return text
    .toString()
    .toLowerCase()
    .replace(/\s+/g, '-')           // Replace spaces with -
    .replace(/[^\w\-]+/g, '')       // Remove all non-word chars
    .replace(/\-\-+/g, '-')         // Replace multiple - with single -
    .replace(/^-+/, '')             // Trim - from start
    .replace(/-+$/, '');            // Trim - from end
};

// 1. GET ALL (Super Optimized)
export const getCollections = async (req: Request, res: Response): Promise<void> => {
  try {
    const userId = (req as any).user?.id;
    const userRole = (req as any).user?.role;
    const targetUserId = req.query.targetUserId as string;

    const whereClause: any = {
      parentId: null
    };

    // ‚úÖ LOGIC: Admin view vs User view
    if (userRole === 'admin' && targetUserId) {
        whereClause.userId = targetUserId;
    } else {
        whereClause.userId = userId;
    }

    // ‚ö°Ô∏è OPTIMIZATION: 
    // 1. We fetch 'coverImage' directly from the column (No heavy joins!)
    // 2. We limit to 100 to prevent server overload
    const collections = await prisma.collection.findMany({
      where: whereClause,
      take: 100, 
      select: {
        id: true,
        name: true,
        createdAt: true,
        coverImage: true, // Direct column access (Fast!)
        _count: {
          select: { assets: true }
        }
      },
      orderBy: { createdAt: 'desc' }
    });

    res.json(collections);
  } catch (error) {
    console.error("Get Collections Error:", error);
    res.status(500).json({ message: 'Error fetching collections' });
  }
};

// 2. GET ONE (Unchanged)
export const getCollectionById = async (req: Request, res: Response): Promise<void> => {
    try {
      const { id } = req.params;
      const userId = (req as any).user?.id;
      const userRole = (req as any).user?.role;
  
      const collection = await prisma.collection.findUnique({
        where: { id },
        include: {
            children: {
                include: { _count: { select: { assets: true } } }
            },
            assets: {
                include: {
                    asset: {
                        include: { uploadedBy: { select: { name: true } } }
                    }
                }
            }
        }
      });
  
      if (!collection) {
        res.status(404).json({ message: 'Collection not found' });
        return;
      }

      if (userRole !== 'admin' && collection.userId !== userId) {
          res.status(403).json({ message: 'Access denied' });
          return;
      }
  
      // Flatten structure for frontend convenience
      const flatCollection = {
          ...collection,
          assets: collection.assets.map(a => a.asset)
      };
  
      res.json(flatCollection);
    } catch (error) {
      res.status(500).json({ message: 'Server error' });
    }
};

// 3. CREATE (Optimized: Fail-Fast Strategy)
export const createCollection = async (req: Request, res: Response): Promise<void> => {
  try {
    const { name, parentId } = req.body;
    const userId = (req as any).user?.id;
    
    const baseSlug = slugify(name);
    let slug = baseSlug;

    // ‚ö°Ô∏è OPTIMIZATION: Try to create immediately. 
    // We assume the name is unique most of the time.
    // This saves 1 DB call (findUnique) for every successful creation.
    try {
        const collection = await prisma.collection.create({
            data: {
                name,
                slug,
                userId,
                parentId: parentId || null
            }
        });
        res.status(201).json(collection);
        return;

    } catch (dbError: any) {
        // P2002 = Unique Constraint Failed (Slug collision)
        if (dbError.code === 'P2002') {
            // Collision happened! Now append timestamp and retry.
            slug = `${baseSlug}-${Date.now()}`;
            const collectionRetry = await prisma.collection.create({
                data: {
                    name,
                    slug,
                    userId,
                    parentId: parentId || null
                }
            });
            res.status(201).json(collectionRetry);
            return;
        }
        throw dbError; // Throw other errors to the main catch block
    }

  } catch (error) {
    console.error(error);
    res.status(500).json({ message: 'Error creating collection' });
  }
};

// 4. ADD ASSET TO COLLECTION (Auto-update Cover)
export const addAssetToCollection = async (req: Request, res: Response): Promise<void> => {
    try {
        const { id } = req.params; 
        const { assetId } = req.body;
        const userId = (req as any).user?.id;
        const userRole = (req as any).user?.role;

        // 1. Fetch Collection to check rights & current cover status
        const collection = await prisma.collection.findUnique({ 
            where: { id },
            select: { userId: true, coverImage: true } 
        });
        
        if (!collection) { res.status(404).json({ message: 'Not found' }); return; }
        
        if (userRole !== 'admin' && collection.userId !== userId) {
            res.status(403).json({ message: 'Access denied' });
            return;
        }

        // 2. Fetch the Asset details (we need the path for the cover)
        const asset = await prisma.asset.findUnique({ 
            where: { id: assetId },
            select: { thumbnailPath: true, path: true }
        });

        if (!asset) { res.status(404).json({ message: 'Asset not found' }); return; }

        // 3. Prepare Transaction Operations
        const operations: any[] = [
            prisma.assetOnCollection.create({
                data: { collectionId: id, assetId }
            })
        ];

        // ‚úÖ LOGIC: If collection has no cover, use this new asset immediately
        if (!collection.coverImage) {
            const newCover = asset.thumbnailPath || asset.path;
            operations.push(
                prisma.collection.update({
                    where: { id },
                    data: { coverImage: newCover }
                })
            );
        }

        // Execute all updates atomically
        await prisma.$transaction(operations);

        res.json({ success: true });
    } catch (error) {
        // Ignore P2002 (Duplicate entry) - means asset is already in collection
        res.json({ success: true });
    }
};

// 5. REMOVE ASSET (Recalculate Cover if needed)
export const removeAssetFromCollection = async (req: Request, res: Response): Promise<void> => {
  try {
      const { id, assetId } = req.params;
      const userId = (req as any).user?.id;
      const userRole = (req as any).user?.role;

      const collection = await prisma.collection.findUnique({ where: { id } });
      if (!collection) { res.status(404).json({ message: 'Not found' }); return; }

      if (userRole !== 'admin' && collection.userId !== userId) {
          res.status(403).json({ message: 'Access denied' });
          return;
      }

      // 1. Get the asset we are about to remove (to check if it's the cover)
      const assetToRemove = await prisma.asset.findUnique({
          where: { id: assetId },
          select: { thumbnailPath: true, path: true }
      });

      // 2. Remove the link
      await prisma.assetOnCollection.deleteMany({
          where: { collectionId: id, assetId: assetId }
      });

      // 3. ‚úÖ CHECK: Did we just delete the cover image?
      const currentCover = collection.coverImage;
      const removedImage = assetToRemove?.thumbnailPath || assetToRemove?.path;

      if (currentCover && removedImage && currentCover === removedImage) {
          
          // Find the most recent asset remaining in the collection
          // ‚úÖ FIX: Use 'assignedAt' instead of 'createdAt'
          const nextAssetLink = await prisma.assetOnCollection.findFirst({
              where: { collectionId: id },
              include: { asset: { select: { thumbnailPath: true, path: true } } },
              orderBy: { assignedAt: 'desc' } 
          });

          // If found, use it. If not (folder empty), set to null.
          const newCover = nextAssetLink?.asset.thumbnailPath || nextAssetLink?.asset.path || null;

          await prisma.collection.update({
              where: { id },
              data: { coverImage: newCover }
          });
      }

      res.json({ success: true });
  } catch (error) {
      console.error("Remove Asset Error:", error);
      res.status(500).json({ message: 'Error removing asset' });
  }
};

// 6. UPDATE COLLECTION (Rename)
export const updateCollection = async (req: Request, res: Response): Promise<void> => {
  try {
    const { id } = req.params;
    const { name } = req.body;
    const userId = (req as any).user?.id;
    const userRole = (req as any).user?.role;

    const collection = await prisma.collection.findUnique({ where: { id } });
    if (!collection) { res.status(404).json({ message: 'Collection not found' }); return; }

    if (userRole !== 'admin' && collection.userId !== userId) {
        res.status(403).json({ message: 'Access denied' });
        return;
    }

    const updated = await prisma.collection.update({
        where: { id },
        data: { name }
    });

    res.json(updated);
  } catch (error) {
    res.status(500).json({ message: 'Error updating collection' });
  }
};

// 7. DELETE COLLECTION (Recursive Force Delete)
export const deleteCollection = async (req: Request, res: Response): Promise<void> => {
  try {
    const { id } = req.params;
    const userId = (req as any).user?.id;
    const userRole = (req as any).user?.role;

    // 1. Fetch the collection AND all its children (recursive) to check permissions
    // Note: A simple check is enough, we will let the DB cascade handle the deep structure
    // provided we clean up the Asset links first.
    const collection = await prisma.collection.findUnique({ where: { id } });

    if (!collection) {
        res.status(404).json({ message: 'Collection not found' });
        return;
    }

    if (userRole !== 'admin' && collection.userId !== userId) {
        res.status(403).json({ message: 'Access denied' });
        return;
    }

    // 2. FORCE DELETE STRATEGY
    // We need to find ALL descendent collection IDs to remove their AssetOnCollection links first.
    // Prisma doesn't support recursive deleteMany easily, so we fetch IDs first.
    
    // Get all collections owned by this user (optimization: we assume we only delete our own tree)
    const allUserCollections = await prisma.collection.findMany({
        where: { userId: collection.userId },
        select: { id: true, parentId: true }
    });

    // Helper to find all descendants of the target ID
    const getDescendants = (parentId: string): string[] => {
        const children = allUserCollections.filter(c => c.parentId === parentId);
        let ids = children.map(c => c.id);
        children.forEach(c => {
            ids = [...ids, ...getDescendants(c.id)];
        });
        return ids;
    };

    const targetIds = [id, ...getDescendants(id)];

    // 3. TRANSACTION
    await prisma.$transaction([
        // A. Remove all asset links from the target folder AND all sub-folders
        prisma.assetOnCollection.deleteMany({
            where: { collectionId: { in: targetIds } }
        }),
        
        // B. Delete the parent collection. 
        // Since schema has `onDelete: Cascade` for `children`, this wipes the sub-folders automatically.
        prisma.collection.delete({
            where: { id }
        })
    ]);

    res.json({ message: 'Collection deleted successfully' });
  } catch (error) {
    console.error("Delete Collection Error:", error);
    res.status(500).json({ message: 'Error deleting collection' });
  }
};

================================================
FILE: src/controllers/feedback.controller.ts
================================================
import { Request, Response } from 'express';
import { PrismaClient } from '@prisma/client';
import { AuthRequest } from '../middleware/auth.middleware';
import { uploadToSupabase } from '../utils/supabase'; // ‚úÖ Import upload utility
import fs from 'fs-extra'; // ‚úÖ Import fs for cleanup

const prisma = new PrismaClient();

// Helper Interface for File Uploads
interface MulterRequest extends Request {
  file?: Express.Multer.File;
  user?: { id: string };
}

// --- 1. Create Feedback (With Attachment Support) ---
export const submitFeedback = async (req: Request, res: Response) => {
  const authReq = req as AuthRequest & MulterRequest;
  const { type, subject, message } = req.body;
  const userId = authReq.user?.id;

  if (!userId) return res.status(401).json({ message: "User not identified" });
  if (!subject || !message) return res.status(400).json({ message: "Subject and message required" });

  let attachmentUrl = null;

  try {
    // ‚úÖ Handle File Upload
    if (authReq.file) {
      try {
        const { path: tempPath, originalname, mimetype } = authReq.file;
        const ext = originalname.split('.').pop();
        const filename = `feedback/${userId}-${Date.now()}.${ext}`;

        // Upload to Supabase bucket
        attachmentUrl = await uploadToSupabase(tempPath, filename, mimetype);
        
        // Clean up temp file
        await fs.remove(tempPath).catch(() => {});
      } catch (uploadError) {
        console.error("Attachment upload failed:", uploadError);
        // We continue creating the feedback even if upload fails, but you could return error here
      }
    }

    // Save to Database
    const newFeedback = await prisma.feedback.create({
      data: {
        userId,
        type,
        subject,
        message,
        attachment: attachmentUrl, // ‚úÖ Save the URL
        status: 'new'
      }
    });

    res.status(201).json(newFeedback);

  } catch (error) {
    console.error("Submit Feedback Error:", error);
    // Cleanup file if DB failed
    if (authReq.file?.path) {
        await fs.remove(authReq.file.path).catch(() => {});
    }
    res.status(500).json({ message: "Server error" });
  }
};

// --- 2. Get All Feedback (Admin) ---
export const getAllFeedback = async (req: Request, res: Response) => {
  try {
    const allFeedback = await prisma.feedback.findMany({
      orderBy: { createdAt: 'desc' },
      include: {
        user: { select: { name: true, email: true, avatar: true } }
      }
    });

    res.json(allFeedback);
  } catch (error) {
    console.error("Get Feedback Error:", error);
    res.status(500).json({ message: "Server error" });
  }
};

// --- 3. Update Status (Admin) ---
export const updateFeedbackStatus = async (req: Request, res: Response) => {
  try {
    const { id } = req.params;
    const { status } = req.body;

    const updated = await prisma.feedback.update({
      where: { id },
      data: { status }
    });

    res.json(updated);
  } catch (error) {
    res.status(500).json({ message: "Server error" });
  }
};

// --- 4. Reply to Feedback (Admin) ---
export const replyToFeedback = async (req: Request, res: Response) => {
  try {
    const { id } = req.params;
    const { message } = req.body; 

    if (!message) return res.status(400).json({ message: "Reply message is required" });

    const updatedFeedback = await prisma.feedback.update({
      where: { id },
      data: { 
        adminReply: message, 
        repliedAt: new Date(),
        status: 'resolved' // Auto-mark resolved on reply
      }
    });

    res.json({ message: "Reply posted successfully", feedback: updatedFeedback });

  } catch (error) {
    console.error("Reply Error:", error);
    res.status(500).json({ message: "Server error" });
  }
};

// --- 5. Delete Feedback (Admin) ---
export const deleteFeedback = async (req: Request, res: Response) => {
  try {
    const { id } = req.params;
    await prisma.feedback.delete({ where: { id } });
    res.json({ message: "Feedback deleted" });
  } catch (error) {
    res.status(500).json({ message: "Server error" });
  }
};

// --- 6. Get My Feedback (User view) ---
export const getMyFeedback = async (req: Request, res: Response) => {
  try {
    const userId = (req as AuthRequest).user?.id;
    
    if (!userId) return res.status(401).json({ message: "Unauthorized" });

    const myFeedback = await prisma.feedback.findMany({
      where: { userId },
      orderBy: { createdAt: 'desc' }
    });

    res.json(myFeedback);
  } catch (error) {
    res.status(500).json({ message: "Server error" });
  }
};

// --- 7. Delete Own Feedback (User) ---
export const deleteOwnFeedback = async (req: Request, res: Response) => {
  try {
    const { id } = req.params;
    const userId = (req as AuthRequest).user?.id;

    if (!userId) return res.status(401).json({ message: "Unauthorized" });

    // Check ownership
    const feedback = await prisma.feedback.findUnique({ where: { id } });

    if (!feedback) return res.status(404).json({ message: "Feedback not found" });
    if (feedback.userId !== userId) return res.status(403).json({ message: "Forbidden" });

    // Delete
    await prisma.feedback.delete({ where: { id } });

    res.json({ message: "Feedback deleted successfully" });
  } catch (error) {
    console.error("Delete Error:", error);
    res.status(500).json({ message: "Server error" });
  }
};

================================================
FILE: src/controllers/trash.controller.ts
================================================
import { Request, Response } from 'express';
import { PrismaClient } from '@prisma/client';
import fs from 'fs';
import path from 'path';

const prisma = new PrismaClient();

// 1. GET /assets/trash - List deleted items
export const getTrash = async (req: Request, res: Response) => {
  try {
    const page = Number(req.query.page) || 1;
    const limit = Number(req.query.limit) || 15;
    const skip = (page - 1) * limit;

    // Fetch items WHERE deletedAt is NOT null
    const [assets, total] = await Promise.all([
      prisma.asset.findMany({
        where: { NOT: { deletedAt: null } },
        orderBy: { deletedAt: 'desc' }, // Newest trash first
        skip,
        take: limit,
      }),
      prisma.asset.count({ where: { NOT: { deletedAt: null } } })
    ]);

    res.json({
      results: assets,
      total,
      totalPages: Math.ceil(total / limit),
      currentPage: page
    });
  } catch (error) {
    console.error("Get Trash Error:", error);
    res.status(500).json({ error: 'Failed to fetch trash' });
  }
};

// 2. POST /assets/:id/restore - Restore from Trash
export const restoreAsset = async (req: Request, res: Response) => {
  try {
    const asset = await prisma.asset.update({
      where: { id: req.params.id },
      data: { deletedAt: null } // ‚ôªÔ∏è Set deletedAt back to null
    });
    res.json({ message: 'Asset restored successfully', asset });
  } catch (error) {
    console.error("Restore Error:", error);
    res.status(500).json({ error: 'Failed to restore asset' });
  }
};

// 3. DELETE /assets/:id/force - Permanently Delete
export const forceDeleteAsset = async (req: Request, res: Response) => {
  try {
    const asset = await prisma.asset.findUnique({ where: { id: req.params.id } });
    if (!asset) return res.status(404).json({ message: 'Asset not found' });

    // A. Delete physical file
    const filePath = path.join(process.cwd(), 'uploads', asset.filename); 
    if (fs.existsSync(filePath)) {
        try { fs.unlinkSync(filePath); } catch (e) { console.error("File delete error:", e); }
    }

    // B. Delete thumbnail if exists
    if (asset.thumbnailPath) {
        const thumbPath = path.join(process.cwd(), 'uploads', asset.thumbnailPath);
        if (fs.existsSync(thumbPath)) {
            try { fs.unlinkSync(thumbPath); } catch (e) { console.error("Thumb delete error:", e); }
        }
    }

    // C. Delete DB record
    await prisma.asset.delete({ where: { id: req.params.id } });

    res.json({ message: 'Asset permanently deleted' });
  } catch (error) {
    console.error("Force Delete Error:", error);
    res.status(500).json({ error: 'Failed to delete asset permanently' });
  }
};

// 4. DELETE /assets/trash/empty - Empty Trash
export const emptyTrash = async (req: Request, res: Response) => {
  try {
    const assets = await prisma.asset.findMany({ where: { NOT: { deletedAt: null } } });

    // Delete all files
    assets.forEach(asset => {
        const filePath = path.join(process.cwd(), 'uploads', asset.filename);
        if (fs.existsSync(filePath)) try { fs.unlinkSync(filePath); } catch {}
        
        if (asset.thumbnailPath) {
             const thumbPath = path.join(process.cwd(), 'uploads', asset.thumbnailPath);
             if (fs.existsSync(thumbPath)) try { fs.unlinkSync(thumbPath); } catch {}
        }
    });

    // Clear DB
    await prisma.asset.deleteMany({ where: { NOT: { deletedAt: null } } });
    res.json({ message: 'Trash emptied' });
  } catch (error) {
    console.error("Empty Trash Error:", error);
    res.status(500).json({ error: 'Failed to empty trash' });
  }
};

================================================
FILE: src/controllers/uploadController.ts
================================================
import { Request, Response } from 'express';

export const uploadFile = (req: Request, res: Response) => {
  try {
    console.log("üìÇ [Upload Controller] Request received.");

    if (!req.file) {
      console.error("‚ùå [Upload Controller] No file found in request.");
      return res.status(400).json({ error: 'No file uploaded' });
    }

    // ‚úÖ FIX: Return a relative path. 
    // The frontend will treat this as relative to the current domain (https://dam.capy-dev.com)
    // Nginx will catch the /uploads/ request and serve the file securely.
    const fileUrl = `/uploads/${req.file.filename}`;
    
    console.log("‚úÖ [Upload Controller] Success!");
    console.log(`   - Filename: ${req.file.originalname}`);
    console.log(`   - Saved as: ${req.file.filename}`);
    console.log(`   - Size: ${(req.file.size / 1024).toFixed(2)} KB`);
    console.log(`   - Returning Relative Path: ${fileUrl}`);

    res.status(200).json({
      url: fileUrl,
      filename: req.file.originalname,
      mimetype: req.file.mimetype,
      size: req.file.size
    });
  } catch (error) {
    console.error("üî• [Upload Controller] Exception:", error);
    res.status(500).json({ error: 'Upload failed' });
  }
};

================================================
FILE: src/controllers/user.controller.ts
================================================
import { Request, Response } from 'express';
import { prisma } from '../lib/prisma';
import bcrypt from 'bcryptjs';
import { uploadToSupabase } from '../utils/supabase'; 
import fs from 'fs-extra'; 

// Define Multer Request Type locally
interface MulterRequest extends Request {
  file?: Express.Multer.File;
  user?: { id: string };
}

// ‚úÖ 1. Get All Users
export const getAllUsers = async (req: Request, res: Response): Promise<void> => {
  try {
    const page = parseInt(req.query.page as string) || 1;
    const limit = parseInt(req.query.limit as string) || 10;
    const search = (req.query.search as string) || '';
    const role = (req.query.role as string) || 'all';

    const skip = (page - 1) * limit;

    const whereClause: any = {
      AND: [
        search ? {
          OR: [
            { name: { contains: search, mode: 'insensitive' } },
            { email: { contains: search, mode: 'insensitive' } },
          ],
        } : {},
        role !== 'all' ? { role: role } : {},
      ],
    };

    const [total, users] = await prisma.$transaction([
      prisma.user.count({ where: whereClause }),
      prisma.user.findMany({
        where: whereClause,
        select: { 
          id: true, 
          name: true, 
          email: true, 
          role: true, 
          status: true, 
          createdAt: true,
          updatedAt: true, // ‚úÖ ADDED THIS LINE
          avatar: true 
        },
        orderBy: { createdAt: 'desc' },
        skip,
        take: limit,
      }),
    ]);

    res.json({
      data: users,
      meta: {
        total,
        page,
        limit,
        totalPages: Math.ceil(total / limit),
      },
    });

  } catch (error) {
    console.error("Get Users Error:", error);
    res.status(500).json({ message: 'Error fetching users' });
  }
};

// 2. Approve User Request
export const approveUser = async (req: Request, res: Response): Promise<void> => {
  try {
    const { id } = req.params;
    const { role } = req.body; 

    await prisma.user.update({
      where: { id },
      data: { 
        status: 'ACTIVE',
        role: role || 'viewer' 
      },
    });

    res.json({ message: 'User approved and active' });
  } catch (error) {
    res.status(500).json({ message: 'Error approving user' });
  }
};

// 3. Reject User Request
export const rejectUser = async (req: Request, res: Response): Promise<void> => {
  try {
    const { id } = req.params;
    await prisma.user.delete({ where: { id } });
    res.json({ message: 'User request rejected and removed' });
  } catch (error) {
    res.status(500).json({ message: 'Error rejecting user' });
  }
};

// 4. Update Role (Safe Version)
export const updateUserRole = async (req: Request, res: Response): Promise<void> => {
  try {
    const { id } = req.params;
    const { role } = req.body;

    // Safety: Ensure only valid roles are passed
    const validRoles = ['admin', 'editor', 'viewer'];
    if (!validRoles.includes(role)) {
        res.status(400).json({ message: 'Invalid role provided' });
        return;
    }

    await prisma.user.update({
      where: { id },
      data: { role },
    });

    res.json({ message: 'User role updated' });
  } catch (error) {
    res.status(500).json({ message: 'Error updating role' });
  }
};

// 5. Create User (Admin Action)
export const createUser = async (req: Request, res: Response): Promise<void> => {
  try {
    const { email, password, name, role } = req.body;

    const existing = await prisma.user.findUnique({ where: { email } });
    if (existing) {
      res.status(400).json({ message: 'User already exists' });
      return;
    }

    const hashedPassword = await bcrypt.hash(password, 10);

    const user = await prisma.user.create({
      data: {
        email,
        password: hashedPassword,
        name,
        role,
        status: 'ACTIVE', 
      },
    });

    res.status(201).json(user);
  } catch (error) {
    res.status(500).json({ message: 'Error creating user' });
  }
};

// 6. Update Profile (Preserved & Safe)
export const updateProfile = async (req: Request, res: Response): Promise<void> => {
  const multerReq = req as MulterRequest;
  const user = (req as any).user;
  const userId = user?.id;
  const { name } = req.body;

  if (!userId) {
     res.status(401).json({ message: 'User not authenticated or ID missing' });
     return;
  }

  try {
    let avatarPath = undefined;

    if (multerReq.file) {
      const { path: tempPath, mimetype } = multerReq.file;
      
      avatarPath = await uploadToSupabase(
        tempPath, 
        `avatars/${userId}-${Date.now()}`, 
        mimetype
      );

      await fs.remove(tempPath).catch(() => {});
    }

    const updatedUser = await prisma.user.update({
      where: { id: userId },
      data: {
        name: name,
        ...(avatarPath && { avatar: avatarPath }), 
      },
    });

    const { password, ...userWithoutPassword } = updatedUser;
    res.json(userWithoutPassword);

  } catch (error) {
    console.error("Profile Update Error:", error);
    if (multerReq.file?.path) {
        await fs.remove(multerReq.file.path).catch(() => {});
    }
    res.status(500).json({ message: 'Failed to update profile' });
  }
};

// 7. Get Single User Details
export const getUserById = async (req: Request, res: Response): Promise<void> => {
  try {
    const { id } = req.params;
    
    const user = await prisma.user.findUnique({
      where: { id },
      include: {
        _count: {
          select: { assets: true, collections: true }
        },
        assets: {
          take: 5,
          orderBy: { createdAt: 'desc' },
          select: { id: true, originalName: true, mimeType: true, thumbnailPath: true, createdAt: true }
        }
      }
    });

    if (!user) {
      res.status(404).json({ message: 'User not found' });
      return;
    }

    const { password, ...userData } = user;
    res.json(userData);
  } catch (error) {
    res.status(500).json({ message: 'Error fetching user details' });
  }
};
  
// 8. Delete User (Transaction Safe)
export const deleteUser = async (req: Request, res: Response): Promise<void> => {
  try {
    const { id } = req.params;
    
    const currentUserId = (req as any).user?.id;
    if (id === currentUserId) {
        res.status(400).json({ message: 'You cannot delete your own admin account.' });
        return;
    }

    const userAssets = await prisma.asset.findMany({
        where: { userId: id },
        select: { id: true }
    });
    
    const assetIds = userAssets.map(a => a.id);

    await prisma.$transaction([
        // Remove asset links in collections
        prisma.assetOnCollection.deleteMany({
            where: { assetId: { in: assetIds } }
        }),
        // Remove collections owned by user
        prisma.assetOnCollection.deleteMany({
            where: { collection: { userId: id } }
        }),
        prisma.collection.deleteMany({
            where: { userId: id }
        }),
        // Remove assets owned by user
        prisma.asset.deleteMany({
            where: { userId: id }
        }),
        // Finally, delete user
        prisma.user.delete({
            where: { id }
        })
    ]);

    res.json({ message: 'User and all associated data deleted successfully' });
  } catch (error) {
    console.error("Delete User Error:", error);
    res.status(500).json({ message: 'Error deleting user. Ensure all dependencies are cleared.' });
  }
};

================================================
FILE: src/index.ts
================================================
import express, { Express, Request, Response } from 'express';
import cors from 'cors';
import dotenv from 'dotenv';
import path from 'path';
import http from 'http'; 
import { Server } from 'socket.io'; 

dotenv.config();

// Import Routes
import authRoutes from './routes/auth.routes';
import assetRoutes from './routes/asset.routes';
import userRoutes from './routes/user.routes';
import collectionRoutes from './routes/collection.routes';
import categoryRoutes from './routes/category.routes'; 
import feedbackRoutes from './routes/feedback.routes';
import adminRoutes from './routes/admin.routes';
import analyticsRoutes from './routes/analytics.routes';
import uploadRoutes from './routes/uploadRoutes'; // ‚úÖ Imported

// Import Services
import { initCronJobs } from './services/cron.service';
import { setupSocketIO } from './socket/socketHandler';

const app: Express = express();
const PORT = process.env.PORT || 5000;

// ‚úÖ CREATE HTTP SERVER
const server = http.createServer(app);

// ‚úÖ INITIALIZE SOCKET.IO
const io = new Server(server, {
  cors: {
    origin: [
      'http://localhost:5173', 
      process.env.CLIENT_URL || "" 
    ],
    methods: ["GET", "POST"],
    credentials: true
  }
});

// ‚úÖ MIDDLEWARES
app.use(cors({
  origin: [
    'http://localhost:5173', 
    process.env.CLIENT_URL || "" 
  ],
  methods: ['GET', 'POST', 'PUT', 'DELETE', 'OPTIONS'],
  credentials: true 
}));

app.use(express.json());

// ‚úÖ REGISTER ROUTES
app.use('/api/auth', authRoutes);
app.use('/api/assets', assetRoutes);
app.use('/api/users', userRoutes);
app.use('/api/collections', collectionRoutes);
app.use('/api/categories', categoryRoutes);
app.use('/api/admin', adminRoutes);
app.use('/api/analytics', analyticsRoutes);
app.use('/api/feedback', feedbackRoutes);

// ‚úÖ NEW: Chat Upload Route (This was missing!)
app.use('/api/upload', uploadRoutes); 

// ‚úÖ Serve uploaded files statically
app.use('/uploads', express.static(path.join(__dirname, '../uploads')));

// ‚úÖ SOCKET LOGIC (Only call this once)
console.log('üõ†Ô∏è [Server] Initializing Socket.io...');
setupSocketIO(io);

// Debug Route
app.get('/', (req: Request, res: Response) => {
  res.send('Capydam API is running üêπ');
});

// ‚úÖ START SERVER
server.listen(PORT, () => {
  console.log(`‚ö°Ô∏è [server]: Server is running at http://localhost:${PORT}`);
  console.log(`   - Auth Routes: /api/auth`);
  console.log(`   - Asset Routes: /api/assets`);
  console.log(`   - Upload Route: /api/upload`); // ‚úÖ Verify this shows up
  console.log(`   - Socket.io: Enabled üü¢`);

  // Initialize Cron Jobs
  initCronJobs();
});

================================================
FILE: src/lib/prisma.ts
================================================
import { PrismaClient } from '@prisma/client';

const globalForPrisma = global as unknown as { prisma: PrismaClient };

export const prisma =
  globalForPrisma.prisma ||
  new PrismaClient({
    log: ['warn', 'error'], // Reduced logging to prevent console spam
  });

if (process.env.NODE_ENV !== 'production') globalForPrisma.prisma = prisma;

================================================
FILE: src/lib/storage.ts
================================================
import { S3Client } from '@aws-sdk/client-s3';

// 1. Configuration
// (In a perfect world, these go in your .env file, but this works for now)
const ENDPOINT = "https://storage.capy-dev.com";
const ACCESS_KEY = "admin";
const SECRET_KEY = "CAPYDAM2025"; // ‚úÖ Matches your Docker password

// 2. Initialize Client
export const storageClient = new S3Client({
  region: 'us-east-1', // Required by SDK, ignored by MinIO
  endpoint: ENDPOINT,
  forcePathStyle: true, // Critical for MinIO
  credentials: {
    accessKeyId: ACCESS_KEY,
    secretAccessKey: SECRET_KEY,
  },
});

export const BUCKET_NAME = 'capydam-assets';
export const PUBLIC_URL_BASE = `${ENDPOINT}/${BUCKET_NAME}`;

================================================
FILE: src/middleware/auth.middleware.ts
================================================
import { Request, Response, NextFunction } from 'express';
import jwt from 'jsonwebtoken';

// 1. Export this interface so we can use it in Controllers
export interface AuthRequest extends Request {
  user?: {
    id: string;
    email: string;
    role: string;
  };
}

const JWT_SECRET = process.env.JWT_SECRET || 'secret'; 

export const verifyJWT = (req: Request, res: Response, next: NextFunction) => {
  const token = req.headers.authorization?.split(' ')[1]; // "Bearer <token>"

  if (!token) {
    res.status(401).json({ message: 'Access denied. No token provided.' });
    return;
  }

  try {
    const decoded = jwt.verify(token, JWT_SECRET) as any;
    (req as AuthRequest).user = decoded;
    next();
  } catch (error) {
    res.status(403).json({ message: 'Invalid token' });
    return;
  }
};

// ‚úÖ ADD THIS FUNCTION
export const requireAdmin = (req: Request, res: Response, next: NextFunction) => {
  // Cast to AuthRequest to access .user
  const authReq = req as AuthRequest;
  
  if (!authReq.user || authReq.user.role !== 'admin') {
     res.status(403).json({ message: 'Admin access required' });
     return;
  }
  
  next();
};

================================================
FILE: src/routes/admin.routes.ts
================================================
import { Router } from 'express';
import { getAdminStats } from '../controllers/admin.controller';
import { verifyJWT, requireAdmin } from '../middleware/auth.middleware'; 

const router = Router();

// GET /api/admin/stats
router.get('/stats', verifyJWT, requireAdmin, getAdminStats);

export default router;

================================================
FILE: src/routes/analytics.routes.ts
================================================
import { Router } from 'express';
import { getSystemAnalytics } from '../controllers/analytics.controller';
import { verifyJWT, requireAdmin } from '../middleware/auth.middleware'; 

const router = Router();

// Only Admins can see system analytics
router.get('/', verifyJWT, requireAdmin, getSystemAnalytics);

export default router;

================================================
FILE: src/routes/asset.routes.ts
================================================
import { Router } from 'express';
import multer from 'multer';
import path from 'path';
import { verifyJWT } from '../middleware/auth.middleware'; 
import { 
    uploadAsset, 
    getAssets, 
    getAssetById, 
    updateAsset, 
    deleteAsset, 
    getRelatedAssets, 
    trackAssetClick 
} from '../controllers/asset.controller';

// ‚úÖ IMPORT TRASH CONTROLLERS
// Ensure you renamed the file to 'trash.controller.ts' to match your style
import { 
    getTrash, 
    restoreAsset, 
    forceDeleteAsset, 
    emptyTrash 
} from '../controllers/trash.controller';

const router = Router();

// --- MULTER CONFIG ---
const storage = multer.diskStorage({
  destination: (req, file, cb) => {
    // Ensure this folder exists in your project root!
    cb(null, 'uploads/'); 
  },
  filename: (req, file, cb) => {
    const uniqueSuffix = Date.now() + '-' + Math.round(Math.random() * 1e9);
    cb(null, uniqueSuffix + path.extname(file.originalname));
  },
});

const upload = multer({ 
  storage,
  limits: { fileSize: 50 * 1024 * 1024 }, // 50MB limit
});

// --- ROUTES ---

// 1. TRASH ROUTES (‚ö†Ô∏è Must come BEFORE generic /:id routes)
// Ideally, add an 'isAdmin' middleware here if you have one
router.get('/trash', verifyJWT, getTrash);             // GET /api/assets/trash
router.delete('/trash/empty', verifyJWT, emptyTrash);  // DELETE /api/assets/trash/empty

// 2. STATIC & ACTION ROUTES
router.post('/upload', verifyJWT, upload.single('file'), uploadAsset);
router.post('/track-click', verifyJWT, trackAssetClick);

// 3. SEARCH / BROWSE
router.get('/', verifyJWT, getAssets);

// 4. SPECIFIC ID ROUTES (Must come BEFORE generic /:id)
router.get('/:id/related', verifyJWT, getRelatedAssets);

// ‚úÖ TRASH ITEM ACTIONS
router.post('/:id/restore', verifyJWT, restoreAsset);    // POST /api/assets/:id/restore
router.delete('/:id/force', verifyJWT, forceDeleteAsset); // DELETE /api/assets/:id/force

// 5. GENERIC ID ROUTES (Catch-all for IDs)
router.get('/:id', verifyJWT, getAssetById);
router.patch('/:id', verifyJWT, updateAsset);
router.delete('/:id', verifyJWT, deleteAsset); // Soft Delete

export default router;

================================================
FILE: src/routes/auth.routes.ts
================================================
import { Router } from 'express';
import { login, register, googleCallback, getMe } from '../controllers/auth.controller';
import passport from '../config/passport';
import { verifyJWT } from '../middleware/auth.middleware';




const router = Router();

router.post('/register', register);
router.post('/login', login);
router.get('/me', verifyJWT, getMe); 

// ‚úÖ NEW: SSO Routes
router.get('/google', passport.authenticate('google', { 
    scope: ['profile', 'email'],
    session: false // We use JWT, not session cookies
}));

router.get('/google/callback', 
    passport.authenticate('google', { session: false, failureRedirect: '/login?error=failed' }),
    googleCallback
  );


export default router;

================================================
FILE: src/routes/category.routes.ts
================================================
import { Router } from 'express';
import { verifyJWT } from '../middleware/auth.middleware';
import { 
  getCategories, 
  createCategory, // <--- Ensure this is imported
  deleteCategory,
  updateCategory,
  getCategoryById, 
  addAssetToCategory, 
  removeAssetFromCategory 
} from '../controllers/category.controller';
import path from 'path';
import multer from 'multer';

const router = Router();
const upload = multer({
  dest: path.join(__dirname, '../../uploads/temp'), 
  limits: { fileSize: 10 * 1024 * 1024 } // 10MB limit for covers
});

// Routes
router.get('/', verifyJWT, getCategories);
router.post('/', verifyJWT, createCategory); // <--- This is the one you are hitting
router.get('/:id', verifyJWT, getCategoryById);
router.post('/:id/assets', verifyJWT, addAssetToCategory);
router.patch('/:id', verifyJWT, upload.single('cover'), updateCategory);
router.delete('/:id', verifyJWT, deleteCategory);
router.delete('/:id/assets/:assetId', verifyJWT, removeAssetFromCategory);


export default router;

================================================
FILE: src/routes/collection.routes.ts
================================================
import { Router } from 'express';
import { verifyJWT } from '../middleware/auth.middleware';
import { 
  getCollections, 
  getCollectionById, 
  createCollection, 
  addAssetToCollection, 
  removeAssetFromCollection,
  updateCollection, 
  deleteCollection 
} from '../controllers/collection.controller';

const router = Router();

// Apply JWT check to all routes
router.use(verifyJWT);

// 1. Get All (My Collections)
router.get('/', getCollections);

// 2. Get One (Specific Collection)
router.get('/:id', getCollectionById);

// 3. Create Collection
router.post('/', createCollection);

// 4. Add Asset to Collection
router.post('/:id/assets', addAssetToCollection);

// 5. Remove Asset from Collection
// ‚úÖ Matches controller: const { id, assetId } = req.params;
router.delete('/:id/assets/:assetId', removeAssetFromCollection);

router.patch('/:id', updateCollection);
router.delete('/:id', deleteCollection);

export default router;

================================================
FILE: src/routes/feedback.routes.ts
================================================
import { Router } from 'express';
import { 
  submitFeedback, 
  getAllFeedback, 
  updateFeedbackStatus, 
  deleteFeedback,
  getMyFeedback, 
  replyToFeedback,
  deleteOwnFeedback

} from '../controllers/feedback.controller';
import { verifyJWT, requireAdmin } from '../middleware/auth.middleware';
import multer from 'multer';

const router = Router();
const upload = multer({ dest: 'uploads/' });


router.post('/', verifyJWT, upload.single('attachment'), submitFeedback);
// User Routes
router.post('/', verifyJWT, submitFeedback);
router.get('/my', verifyJWT, getMyFeedback);

router.delete('/my/:id', verifyJWT, deleteOwnFeedback);

// Admin Routes
router.get('/', verifyJWT, requireAdmin, getAllFeedback);
router.patch('/:id', verifyJWT, requireAdmin, updateFeedbackStatus);
router.delete('/:id', verifyJWT, requireAdmin, deleteFeedback);
router.post('/:id/reply', verifyJWT, requireAdmin, replyToFeedback);

export default router;

================================================
FILE: src/routes/uploadRoutes.ts
================================================
import express from 'express';
import multer from 'multer';
import path from 'path';
import fs from 'fs';
import { uploadFile } from '../controllers/uploadController';

const router = express.Router();
const uploadDir = path.join(__dirname, '../../uploads');
if (!fs.existsSync(uploadDir)) fs.mkdirSync(uploadDir, { recursive: true });

const storage = multer.diskStorage({
  destination: (req, file, cb) => cb(null, uploadDir),
  filename: (req, file, cb) => {
    const uniqueSuffix = Date.now() + '-' + Math.round(Math.random() * 1E9);
    cb(null, uniqueSuffix + path.extname(file.originalname));
  }
});

const upload = multer({ storage, limits: { fileSize: 10 * 1024 * 1024 } });
router.post('/', upload.single('file'), uploadFile);

export default router;

================================================
FILE: src/routes/user.routes.ts
================================================
import { Router } from 'express';
import { verifyJWT } from '../middleware/auth.middleware';
import { 
  getAllUsers, 
  approveUser, 
  rejectUser, 
  updateUserRole,
  createUser,
  updateProfile,
  getUserById, 
  deleteUser   
} from '../controllers/user.controller';
import multer from 'multer';
import path from 'path';

const router = Router();

// Apply Auth Middleware to all routes
router.use(verifyJWT);

// Configure Multer
const upload = multer({
  dest: path.join(__dirname, '../../uploads/temp'),
  limits: { fileSize: 10 * 1024 * 1024 }, 
});

// --- ROUTES ---

// 1. Get All Users
router.get('/', getAllUsers);

// 2. Approve User 
// ‚úÖ FIX: Changed PATCH to POST to match frontend 'client.post'
router.post('/:id/approve', approveUser);

// 3. Reject User
router.delete('/:id/reject', rejectUser);

// 4. Update Role 
// ‚úÖ FIX: Changed PATCH to PUT to match frontend 'client.put'
router.put('/:id/role', updateUserRole);

// 5. Create New User
router.post('/', createUser);

// 6. Update Profile
// Note: This must come BEFORE /:id so "profile" isn't treated as an ID
router.patch('/profile', upload.single('avatar'), updateProfile);

// 7. Get Specific User
router.get('/:id', getUserById);

// 8. Delete User
router.delete('/:id', deleteUser);

export default router;

================================================
FILE: src/scripts/ai-rename.ts
================================================
import { PrismaClient } from '@prisma/client';
import { analyzeImage, analyzePdf, analyzeAudioVideo } from '../services/ai.service'; // We reuse your existing service!
import fs from 'fs';
import path from 'path';
import https from 'https';
import dotenv from 'dotenv';

dotenv.config();
const prisma = new PrismaClient();
const TEMP_DIR = path.join(__dirname, 'temp_rename');

// Helper to download file
async function downloadFile(url: string, dest: string): Promise<void> {
  return new Promise((resolve, reject) => {
    const file = fs.createWriteStream(dest);
    https.get(url, (response) => {
      if (response.statusCode !== 200) {
        reject(new Error(`Download failed: ${response.statusCode}`));
        return;
      }
      response.pipe(file);
      file.on('finish', () => {
        file.close();
        resolve();
      });
    }).on('error', (err) => {
      fs.unlink(dest, () => {});
      reject(err);
    });
  });
}

async function runAiRenamer() {
  console.log('üß† Starting AI Renamer...');

  // Ensure temp dir exists
  if (!fs.existsSync(TEMP_DIR)) fs.mkdirSync(TEMP_DIR);

  // 1. Find assets that need fixing
  const assets = await prisma.asset.findMany({
    where: {
      originalName: { startsWith: 'Resource ' }, // Only target the bad names
      // OPTIONAL: Limit to 50 at a time to save costs/time, then run again
      // take: 50 
    }
  });

  console.log(`Found ${assets.length} assets to rename.`);

  for (const asset of assets) {
    console.log(`\nüîç Processing ID: ${asset.id} (${asset.mimeType})`);
    
    // We need a local file for the AI service to work
    const tempFilePath = path.join(TEMP_DIR, asset.filename);

    try {
      // A. Download the file locally
      await downloadFile(asset.path, tempFilePath);

      // B. Run the appropriate AI analysis
      // Note: Your AI service usually updates the DB directly!
      const aiOptions = { creativity: 0.2, specificity: 'general' };

      if (asset.mimeType.startsWith('image/')) {
         await analyzeImage(asset.id, tempFilePath, aiOptions);
      } 
      else if (asset.mimeType === 'application/pdf') {
         await analyzePdf(asset.id, tempFilePath, aiOptions);
      }
      else if (asset.mimeType.startsWith('video/')) {
         // Video analysis is heavy, maybe skip if you want to save $$
         await analyzeAudioVideo(asset.id, tempFilePath, aiOptions);
      }
      else {
         console.log('Skipping unsupported type');
         continue;
      }

      // C. Rename Logic
      // The analyze function updates 'aiData' and 'description', but usually NOT 'originalName'.
      // So we fetch the fresh data and update the name ourselves.
      const updatedAsset = await prisma.asset.findUnique({ where: { id: asset.id } });
      
      if (updatedAsset && updatedAsset.aiData) {
          const aiData = JSON.parse(updatedAsset.aiData);
          
          // Use the AI-generated "Title" or "Summary" as the new name
          let newName = aiData.title || aiData.summary || "";
          
          // Truncate if too long (e.g. "A photo of a red car...") -> "Red Car on Beach"
          if (newName.length > 50) {
              newName = newName.substring(0, 50) + "...";
          }

          if (newName) {
              await prisma.asset.update({
                  where: { id: asset.id },
                  data: { originalName: newName }
              });
              console.log(`‚úÖ Renamed to: "${newName}"`);
          }
      }

    } catch (err: any) {
      console.error(`‚ùå Failed: ${err.message}`);
    } finally {
      // Cleanup temp file
      if (fs.existsSync(tempFilePath)) fs.unlinkSync(tempFilePath);
    }
  }

  console.log('\n‚ú® Renaming Complete!');
  if (fs.existsSync(TEMP_DIR)) fs.rmdirSync(TEMP_DIR);
}

runAiRenamer()
  .catch(e => console.error(e))
  .finally(async () => {
    await prisma.$disconnect();
  });


================================================
FILE: src/scripts/backfill-thumbnails.ts
================================================
import { PrismaClient } from '@prisma/client';
import { uploadToSupabase } from '../services/storage.service';
import { 
  generateThumbnail, 
  generateVideoThumbnail, 
  generatePdfThumbnail 
} from '../services/image.service';
import fs from 'fs-extra';
import path from 'path';
import axios from 'axios';
import dotenv from 'dotenv';

dotenv.config();
const prisma = new PrismaClient();

const TEMP_DIR = path.join(__dirname, '../../uploads/temp_backfill');
const THUMB_DIR = path.join(__dirname, '../../uploads/thumbnails');

// Helper: Download file from URL
async function downloadFile(url: string, dest: string) {
    const writer = fs.createWriteStream(dest);
    const response = await axios({
        url,
        method: 'GET',
        responseType: 'stream'
    });
    response.data.pipe(writer);
    return new Promise((resolve, reject) => {
        writer.on('finish', () => resolve(undefined)); // ‚úÖ Fixed type error
        writer.on('error', reject);
    });
}

async function backfillThumbnails() {
    console.log("üé® Starting Thumbnail Backfill...");

    // Ensure dirs exist
    await fs.ensureDir(TEMP_DIR);
    await fs.ensureDir(THUMB_DIR);

    // 1. Find assets with NO thumbnail (and verify they are valid types)
    const assets = await prisma.asset.findMany({
        where: {
            thumbnailPath: null,
            OR: [
                { mimeType: { startsWith: 'image/' } },
                { mimeType: { startsWith: 'video/' } },
                { mimeType: 'application/pdf' }
            ]
        },
        // Process in batches if you have thousands, but let's do all for now
    });

    console.log(`Found ${assets.length} assets missing thumbnails.`);

    let successCount = 0;
    let errorCount = 0;

    for (const [index, asset] of assets.entries()) {
        const ext = path.extname(asset.originalName) || '.dat';
        const tempFilePath = path.join(TEMP_DIR, `${asset.id}${ext}`);
        
        console.log(`\n[${index + 1}/${assets.length}] Processing: ${asset.originalName}`);

        try {
            // A. Download Original
            // console.log(`   ‚¨áÔ∏è Downloading...`);
            await downloadFile(asset.path, tempFilePath);

            // B. Generate Thumbnail
            let relativeThumbPath: string | null = null;
            
            // console.log(`   ‚öôÔ∏è Generating thumbnail...`);
            if (asset.mimeType.startsWith('image/')) {
                relativeThumbPath = await generateThumbnail(tempFilePath, THUMB_DIR);
            } else if (asset.mimeType.startsWith('video/')) {
                relativeThumbPath = await generateVideoThumbnail(tempFilePath, THUMB_DIR);
            } else if (asset.mimeType === 'application/pdf') {
                relativeThumbPath = await generatePdfThumbnail(tempFilePath, THUMB_DIR);
            }

            if (!relativeThumbPath) throw new Error("Thumbnail generation returned null");

            // C. Upload to Cloud
            // console.log(`   ‚òÅÔ∏è Uploading to Supabase...`);
            const localThumbPath = path.join(__dirname, '../../uploads', relativeThumbPath);
            
            // Determine content type for upload
            const isWebP = relativeThumbPath.endsWith('.webp');
            const contentType = isWebP ? 'image/webp' : 'image/jpeg';

            const cloudThumbPath = await uploadToSupabase(
                localThumbPath,
                relativeThumbPath, // Keep folder structure if service uses it
                contentType
            );

            // D. Update DB
            await prisma.asset.update({
                where: { id: asset.id },
                data: { thumbnailPath: cloudThumbPath }
            });

            // Cleanup local generated thumb
            await fs.remove(localThumbPath);
            
            console.log(`   ‚úÖ Success! Thumbnail linked.`);
            successCount++;

        } catch (err: any) {
            console.error(`   ‚ùå Failed: ${err.message}`);
            errorCount++;
        } finally {
            // Cleanup downloaded original
            if (await fs.pathExists(tempFilePath)) {
                await fs.remove(tempFilePath);
            }
        }
    }

    console.log(`\n‚ú® Backfill Complete! Success: ${successCount}, Errors: ${errorCount}`);
    
    // Final Cleanup
    await fs.remove(TEMP_DIR);
    // Note: THUMB_DIR might be needed by the app, so we keep it or check logic
}

backfillThumbnails()
    .catch(e => console.error(e))
    .finally(async () => {
        await prisma.$disconnect();
    });


================================================
FILE: src/scripts/check-descriptions.ts
================================================
import { PrismaClient } from '@prisma/client';

const prisma = new PrismaClient();

async function checkDescriptions() {
  console.log("üîç Checking database for descriptions...\n");

  // Get 10 random migrated assets
  const assets = await prisma.asset.findMany({
    where: { 
        filename: { startsWith: 'migration/' } 
    },
    take: 10,
    select: { id: true, filename: true, aiData: true }
  });

  if (assets.length === 0) {
      console.log("‚ùå No migrated assets found!");
      return;
  }

  assets.forEach(asset => {
      console.log(`------------------------------------------------`);
      console.log(`üìÇ File: ${asset.filename}`);
      
      try {
          const data = JSON.parse(asset.aiData || '{}');
          
          // Check all possible description fields
          const desc = data.description;
          const summ = data.summary;
          const capt = data.caption;
          
          if (desc) console.log(`‚úÖ description: "${desc.substring(0, 100)}..."`);
          else console.log(`‚ùå description: NULL`);

          if (summ) console.log(`‚úÖ summary:     "${summ.substring(0, 100)}..."`);
          else console.log(`‚ùå summary:     NULL`);

          if (capt) console.log(`‚úÖ caption:     "${capt.substring(0, 100)}..."`);
          else console.log(`‚ùå caption:     NULL`);

      } catch (e) {
          console.log(`‚ùå Error parsing JSON: ${asset.aiData}`);
      }
  });
  console.log(`------------------------------------------------`);
}

checkDescriptions()
  .catch(e => console.error(e))
  .finally(async () => {
    await prisma.$disconnect();
  });


================================================
FILE: src/scripts/check-filenames.ts
================================================
import { PrismaClient } from '@prisma/client';
const prisma = new PrismaClient();

async function check() {
  console.log("üîç Checking first 10 assets...");
  const assets = await prisma.asset.findMany({
    take: 10,
    select: { id: true, filename: true, originalName: true }
  });
  console.table(assets);
}

check().finally(() => prisma.$disconnect());



================================================
FILE: src/scripts/check-status.ts
================================================
/// <reference types="node" />
import { PrismaClient } from '@prisma/client';

const prisma = new PrismaClient();

async function checkStatus() {
  console.log("üìä Checking Migration Status...");

  // 1. Fetch all video assets (just IDs and frames to be fast)
  const assets = await prisma.asset.findMany({
    where: { mimeType: { startsWith: 'video/' } },
    select: { id: true, previewFrames: true }
  });

  let totalVideos = assets.length;
  let remaining = 0;
  let migrated = 0;

  for (const asset of assets) {
    // Check if frames exist and if the first one points to Supabase
    if (asset.previewFrames && asset.previewFrames.length > 0) {
      if (asset.previewFrames[0].includes('supabase.co')) {
        remaining++;
      } else {
        migrated++;
      }
    } else {
      // No frames = considered "done" or not applicable
      migrated++;
    }
  }

  console.log(`\n=============================`);
  console.log(`üé• Total Videos:     ${totalVideos}`);
  console.log(`‚úÖ Fully Migrated:   ${migrated}`);
  console.log(`‚è≥ Remaining:        ${remaining}`);
  console.log(`=============================`);
  
  const percentage = ((migrated / totalVideos) * 100).toFixed(1);
  console.log(`üöÄ Progress: ${percentage}% Complete`);
}

checkStatus()
  .catch(console.error)
  .finally(() => prisma.$disconnect());


================================================
FILE: src/scripts/check-thumbnails.ts
================================================
import { PrismaClient } from '@prisma/client';

const prisma = new PrismaClient();

async function checkThumbnails() {
  console.log("üîç Checking Thumbnail Status...\n");

  // 1. Count Total
  const total = await prisma.asset.count();
  
  // 2. Count Missing Thumbnails
  const missing = await prisma.asset.count({
    where: { thumbnailPath: null }
  });

  // 3. Count Present Thumbnails
  const present = await prisma.asset.count({
    where: { thumbnailPath: { not: null } }
  });

  console.log(`üìä STATS:`);
  console.log(`- Total Assets:   ${total}`);
  console.log(`- ‚úÖ With Thumb:  ${present}`);
  console.log(`- ‚ùå No Thumb:    ${missing}`);
  console.log(`------------------------------------------------`);

  if (missing > 0) {
      console.log(`‚ö†Ô∏è You have ${missing} assets causing the lag!`);
      console.log(`Here are the first 5 offenders:\n`);

      const examples = await prisma.asset.findMany({
          where: { thumbnailPath: null },
          take: 5,
          select: { id: true, filename: true, mimeType: true }
      });

      console.table(examples);
  } else {
      console.log(`üéâ All assets have thumbnails! The lag might be elsewhere.`);
  }
}

checkThumbnails()
  .catch(e => console.error(e))
  .finally(async () => {
    await prisma.$disconnect();
  });


================================================
FILE: src/scripts/clear-chat.ts
================================================
// server/clear-chat.ts
import { PrismaClient } from '@prisma/client';
const prisma = new PrismaClient();

async function main() {
  console.log('üóëÔ∏è  Cleaning Chat Data...');
  
  // Order matters due to Foreign Keys!
  await prisma.notification.deleteMany({});
  await prisma.reaction.deleteMany({});
  await prisma.message.deleteMany({});
  await prisma.membership.deleteMany({});
  await prisma.chatRoom.deleteMany({});
  
  console.log('‚ú® Chat tables wiped successfully!');
}

main()
  .catch(e => console.error(e))
  .finally(async () => await prisma.$disconnect());

================================================
FILE: src/scripts/fix-and-verify.ts
================================================
import { PrismaClient } from '@prisma/client';

const prisma = new PrismaClient();

async function run() {
  console.log("üßπ Starting Cleanup & Verification...\n");

  // --- TASK 1: FIX RAR FILES ---
  console.log("1Ô∏è‚É£ Fixing broken RAR assets...");
  const rarUpdates = await prisma.asset.updateMany({
    where: { 
        mimeType: 'image/rar' // Incorrect type causing browser lag
    },
    data: { 
        mimeType: 'application/vnd.rar' // Correct type (shows file icon)
    }
  });
  console.log(`   ‚úÖ Fixed ${rarUpdates.count} RAR files. They will no longer choke the image loader.\n`);

  // --- TASK 2: VERIFY THUMBNAILS ---
  console.log("2Ô∏è‚É£ Verifying Thumbnail Paths...");
  const samples = await prisma.asset.findMany({
    where: { thumbnailPath: { not: null } },
    take: 5,
    select: { id: true, filename: true, path: true, thumbnailPath: true }
  });

  console.log("   Checking if thumbnails are real or just clones of the original...");
  
  let suspiciousCount = 0;
  samples.forEach((asset, i) => {
      const isThumbInFolder = asset.thumbnailPath?.includes('thumbnails/');
      const isThumbSameAsOriginal = asset.thumbnailPath === asset.path;

      console.log(`   [${i+1}] ${asset.filename}`);
      console.log(`       Original:  ${asset.path}`);
      console.log(`       Thumbnail: ${asset.thumbnailPath}`);
      
      if (isThumbSameAsOriginal || !isThumbInFolder) {
          console.log(`       ‚ö†Ô∏è SUSPICIOUS: This looks like the original file!`);
          suspiciousCount++;
      } else {
          console.log(`       ‚úÖ GOOD: Looks like a real thumbnail.`);
      }
      console.log('---');
  });

  if (suspiciousCount > 0) {
      console.log("\nüö® DIAGNOSIS: Your 'thumbnails' are actually full-size original files.");
      console.log("   This is why the dashboard is heavy. You need to run the backfill script.");
  } else {
      console.log("\n‚úÖ DIAGNOSIS: Thumbnails look correct. The lag might be caching or network related.");
  }
}

run()
  .catch(e => console.error(e))
  .finally(async () => {
    await prisma.$disconnect();
  });


================================================
FILE: src/scripts/generate-context.ts
================================================
/// <reference types="node" />
import fs from 'fs';
import path from 'path';

// 1. CONFIGURATION
const ROOT_DIR = path.resolve(__dirname, '../..'); // Points to 'server/'
const OUTPUT_FILE = path.join(ROOT_DIR, 'full_codebase_context.txt');

// Folders/Files to IGNORE (Noise)
const IGNORE_PATTERNS = [
  'node_modules', 
  '.git', 
  'dist', 
  'coverage', 
  'package-lock.json', 
  'yarn.lock',
  '.env',
  'migration_errors.log',
  'uploads',
  'README.md'
];

// File extensions we actually care about
const INCLUDE_EXTENSIONS = ['.ts', '.js', '.prisma', '.json', '.sql'];

function shouldIgnore(entryName: string): boolean {
  return IGNORE_PATTERNS.some(pattern => entryName.includes(pattern));
}

function scanDirectory(dir: string, fileList: string[] = []) {
  const entries = fs.readdirSync(dir);

  for (const entry of entries) {
    const fullPath = path.join(dir, entry);
    const relPath = path.relative(ROOT_DIR, fullPath);

    if (shouldIgnore(entry)) continue;

    const stat = fs.statSync(fullPath);

    if (stat.isDirectory()) {
      scanDirectory(fullPath, fileList);
    } else {
      const ext = path.extname(entry);
      if (INCLUDE_EXTENSIONS.includes(ext)) {
        fileList.push(fullPath);
      }
    }
  }
  return fileList;
}

function generateContext() {
  console.log(`üöÄ Scanning codebase at: ${ROOT_DIR}...`);
  
  const files = scanDirectory(ROOT_DIR);
  let content = `PROJECT CODEBASE CONTEXT\nGenerated on: ${new Date().toISOString()}\n\n`;

  // 1. Add Directory Structure (Tree) first
  content += `=== FILE STRUCTURE ===\n`;
  files.forEach(f => content += `- ${path.relative(ROOT_DIR, f)}\n`);
  content += `\n======================\n\n`;

  // 2. Add File Contents
  let fileCount = 0;
  for (const file of files) {
    try {
      const fileContent = fs.readFileSync(file, 'utf-8');
      const relPath = path.relative(ROOT_DIR, file);
      
      content += `\n\n================================================\n`;
      content += `FILE: ${relPath}\n`;
      content += `================================================\n`;
      content += fileContent;
      
      fileCount++;
      process.stdout.write('.'); // Progress dot
    } catch (e) {
      console.error(`\n‚ùå Error reading ${file}`);
    }
  }

  fs.writeFileSync(OUTPUT_FILE, content);
  console.log(`\n\n‚úÖ Done! Read ${fileCount} files.`);
  console.log(`üìÑ Output saved to: ${OUTPUT_FILE}`);
}

generateContext();


================================================
FILE: src/scripts/generate-thumbnails.ts
================================================
import { PrismaClient } from '@prisma/client';
import { createClient } from '@supabase/supabase-js';
import ffmpeg from 'fluent-ffmpeg';
import fs from 'fs';
import path from 'path';
import dotenv from 'dotenv';
import https from 'https';

dotenv.config();

const prisma = new PrismaClient();
const supabase = createClient(process.env.SUPABASE_URL!, process.env.SUPABASE_KEY!);

// Temp folder for processing
const TEMP_DIR = path.join(__dirname, 'temp_videos');

// Helper to download file from Supabase
async function downloadFile(url: string, dest: string): Promise<void> {
  return new Promise((resolve, reject) => {
    const file = fs.createWriteStream(dest);
    https.get(url, (response) => {
      if (response.statusCode !== 200) {
        reject(new Error(`Failed to download: ${response.statusCode}`));
        return;
      }
      response.pipe(file);
      file.on('finish', () => {
        file.close();
        resolve();
      });
    }).on('error', (err) => {
      fs.unlink(dest, () => {});
      reject(err);
    });
  });
}

async function generateThumbnails() {
  console.log('üé¨ Starting Fix for Migrated Video Thumbnails...');

  // Ensure temp dir exists
  if (!fs.existsSync(TEMP_DIR)) fs.mkdirSync(TEMP_DIR);

  // 1. Find ALL videos
  const videos = await prisma.asset.findMany({
    where: {
      mimeType: { startsWith: 'video/' },
    }
  });

  console.log(`Found ${videos.length} total videos.`);

  for (const video of videos) {
    // 2. SKIP VALID ONES
    // If it has a thumbnail AND that thumbnail is a JPG/PNG, it's good.
    // If thumbnail is NULL or ends in .mp4 (our fallback), it's BROKEN -> Fix it.
    const isBroken = !video.thumbnailPath || video.thumbnailPath.endsWith('.mp4') || video.thumbnailPath.endsWith('.m4v');
    
    if (!isBroken) {
        // console.log(`Skipping good video: ${video.originalName}`);
        continue;
    }

    console.log(`üî® Fixing: ${video.originalName} (ID: ${video.id})`);

    const videoPath = path.join(TEMP_DIR, `${video.id}_temp.mp4`);
    const thumbName = `${video.id}_thumb.jpg`;
    const thumbPath = path.join(TEMP_DIR, thumbName);

    try {
      // A. Download Video
      await downloadFile(video.path, videoPath);

      // B. Generate Thumbnail (Screenshot at 1 sec)
      await new Promise((resolve, reject) => {
        ffmpeg(videoPath)
          .screenshots({
            timestamps: ['1'], // Take shot at 1 second mark
            filename: thumbName,
            folder: TEMP_DIR,
            size: '320x?', // Width 320px, auto height
          })
          .on('end', resolve)
          .on('error', reject);
      });

      // C. Upload to Supabase
      const fileBuffer = fs.readFileSync(thumbPath);
      const cloudPath = `thumbnails/${thumbName}`; // Save as clean JPG

      const { error: uploadError } = await supabase.storage
        .from('assets')
        .upload(cloudPath, fileBuffer, { 
            contentType: 'image/jpeg',
            upsert: true 
        });

      if (uploadError) throw uploadError;

      const { data: publicUrl } = supabase.storage
        .from('assets')
        .getPublicUrl(cloudPath);

      // D. Update Database with the NEW JPG Link
      await prisma.asset.update({
        where: { id: video.id },
        data: { thumbnailPath: publicUrl.publicUrl }
      });

      console.log(`‚úÖ Fixed!`);

    } catch (err: any) {
      console.error(`‚ùå Failed ${video.id}: ${err.message}`);
    } finally {
      // Cleanup temp files immediately to save space
      if (fs.existsSync(videoPath)) fs.unlinkSync(videoPath);
      if (fs.existsSync(thumbPath)) fs.unlinkSync(thumbPath);
    }
  }

  console.log('‚ú® All broken thumbnails repaired!');
  if (fs.existsSync(TEMP_DIR)) fs.rmdirSync(TEMP_DIR);
}

generateThumbnails()
  .catch(e => console.error(e))
  .finally(async () => {
    await prisma.$disconnect();
  });


================================================
FILE: src/scripts/migrate-extras.ts
================================================
/// <reference types="node" />

import { PrismaClient } from '@prisma/client';
import axios from 'axios';
import { Upload } from '@aws-sdk/lib-storage';
import { storageClient, BUCKET_NAME, PUBLIC_URL_BASE } from '../lib/storage';

const prisma = new PrismaClient();

// Helper function to handle the move
async function moveFile(oldUrl: string, folderName: string): Promise<string | null> {
  if (!oldUrl || !oldUrl.includes('supabase.co')) return null;

  try {
    console.log(`   -> Moving: ${oldUrl}`);
    const response = await axios({ method: 'get', url: oldUrl, responseType: 'stream' });

    // Try to keep original folder structure or default to provided folder
    let key = oldUrl.split('/assets/')[1];
    if (!key) key = `${folderName}/${oldUrl.split('/').pop()}`;
    
    key = decodeURIComponent(key);

    const upload = new Upload({
      client: storageClient,
      params: {
        Bucket: BUCKET_NAME,
        Key: key,
        Body: response.data,
        ContentType: response.headers['content-type'],
      },
    });

    await upload.done();
    return `${PUBLIC_URL_BASE}/${key}`;
  } catch (e) {
    console.error(`   ‚ùå Failed: ${oldUrl}`);
    return null;
  }
}

async function migrateExtras() {
  console.log("üöÄ Starting CLEANUP Migration (Avatars, Covers, Chat)...");

  // --- 1. USERS (Avatars) ---
  const users = await prisma.user.findMany({ where: { avatar: { contains: 'supabase' } } });
  console.log(`\nFound ${users.length} User Avatars.`);
  for (const u of users) {
    const newUrl = await moveFile(u.avatar!, 'avatars');
    if (newUrl) await prisma.user.update({ where: { id: u.id }, data: { avatar: newUrl } });
  }

  // --- 2. COLLECTIONS (Cover Images) ---
  const collections = await prisma.collection.findMany({ where: { coverImage: { contains: 'supabase' } } });
  console.log(`\nFound ${collections.length} Collection Covers.`);
  for (const c of collections) {
    const newUrl = await moveFile(c.coverImage!, 'covers');
    if (newUrl) await prisma.collection.update({ where: { id: c.id }, data: { coverImage: newUrl } });
  }

  // --- 3. CATEGORIES (Cover Images) ---
  const categories = await prisma.category.findMany({ where: { coverImage: { contains: 'supabase' } } });
  console.log(`\nFound ${categories.length} Category Covers.`);
  for (const c of categories) {
    const newUrl = await moveFile(c.coverImage!, 'covers');
    if (newUrl) await prisma.category.update({ where: { id: c.id }, data: { coverImage: newUrl } });
  }

  // --- 4. FEEDBACK (Attachments) ---
  const feedbacks = await prisma.feedback.findMany({ where: { attachment: { contains: 'supabase' } } });
  console.log(`\nFound ${feedbacks.length} Feedback Attachments.`);
  for (const f of feedbacks) {
    const newUrl = await moveFile(f.attachment!, 'feedback');
    if (newUrl) await prisma.feedback.update({ where: { id: f.id }, data: { attachment: newUrl } });
  }

  // --- 5. MESSAGES (Chat Files) ---
  const messages = await prisma.message.findMany({ where: { attachmentUrl: { contains: 'supabase' } } });
  console.log(`\nFound ${messages.length} Chat Attachments.`);
  for (const m of messages) {
    const newUrl = await moveFile(m.attachmentUrl!, 'chat');
    if (newUrl) await prisma.message.update({ where: { id: m.id }, data: { attachmentUrl: newUrl } });
  }

  console.log("\n‚úÖ All Extras Migrated!");
}

migrateExtras()
  .catch((e) => {
    console.error(e);
    process.exit(1);
  })
  .finally(async () => {
    await prisma.$disconnect();
  });


================================================
FILE: src/scripts/migrate-preview-frames.ts
================================================
/// <reference types="node" />

import { PrismaClient } from '@prisma/client';
import axios from 'axios';
import { Upload } from '@aws-sdk/lib-storage';
import { storageClient, BUCKET_NAME, PUBLIC_URL_BASE } from '../lib/storage';

const prisma = new PrismaClient();

async function migratePreviewFrames() {
  console.log("üöÄ Starting PREVIEW FRAMES (Scrub) Migration...");

  // 1. Get all assets (Since we can't easily filter arrays for partial strings in Prisma, we fetch video assets)
  // Optimization: Only fetching videos reduces the load
  const assets = await prisma.asset.findMany({
    where: {
      mimeType: { startsWith: 'video/' }
    },
    select: { id: true, previewFrames: true } // Only fetch what we need
  });

  console.log(`Checking ${assets.length} video assets for Supabase previews...`);

  let successCount = 0;
  let errorCount = 0;

  for (const asset of assets) {
    // Skip if empty or already migrated (check the first frame)
    if (!asset.previewFrames || asset.previewFrames.length === 0) continue;
    if (!asset.previewFrames[0].includes('supabase.co')) continue;

    console.log(`\nProcessing Asset ID: ${asset.id} (${asset.previewFrames.length} frames)`);

    const newFrames: string[] = [];
    let assetHasError = false;

    // 2. Loop through every frame in the list
    for (const frameUrl of asset.previewFrames) {
      try {
        // Download
        const response = await axios({
          method: 'get',
          url: frameUrl,
          responseType: 'stream'
        });

        // Determine Filename (e.g., "previews/1468...-scrub-10.jpg")
        let destinationKey = frameUrl.split('/assets/')[1];
        if (!destinationKey) {
            destinationKey = `previews/${frameUrl.split('/').pop()}`;
        }
        destinationKey = decodeURIComponent(destinationKey);

        // Upload to MinIO
        const upload = new Upload({
          client: storageClient,
          params: {
            Bucket: BUCKET_NAME,
            Key: destinationKey,
            Body: response.data,
            ContentType: 'image/jpeg',
          },
        });

        await upload.done();

        // Add new URL to our list
        newFrames.push(`${PUBLIC_URL_BASE}/${destinationKey}`);

      } catch (error) {
        console.error(`‚ùå Failed to move frame: ${frameUrl}`);
        assetHasError = true;
        // Keep the old URL if migration fails so we don't break the array
        newFrames.push(frameUrl); 
      }
    }

    // 3. Update the Database with the new list
    if (!assetHasError) {
      await prisma.asset.update({
        where: { id: asset.id },
        data: { previewFrames: newFrames }
      });
      console.log(`‚úÖ Asset updated successfully.`);
      successCount++;
    } else {
      errorCount++;
    }
  }
  
  console.log(`\nJob Complete! ‚úÖ Assets Updated: ${successCount} | ‚ùå Errors: ${errorCount}`);
}

migratePreviewFrames()
  .catch((e) => {
    console.error(e);
    process.exit(1);
  })
  .finally(async () => {
    await prisma.$disconnect();
  });

================================================
FILE: src/scripts/migrate-storage.ts
================================================
/// <reference types="node" />

import { PrismaClient } from '@prisma/client';
import axios from 'axios';
import { Upload } from '@aws-sdk/lib-storage';
// ‚úÖ Import changed: We are now inside src, so we go up one level (..) to lib
import { storageClient, BUCKET_NAME, PUBLIC_URL_BASE } from '../lib/storage';

const prisma = new PrismaClient();

async function migrate() {
  console.log("üöÄ Starting Storage Migration...");

  const assets = await prisma.asset.findMany({
    where: {
      path: {
        contains: 'supabase.co' 
      }
    }
  });

  console.log(`Found ${assets.length} files to migrate.`);

  let successCount = 0;
  let errorCount = 0;

  for (const asset of assets) {
    try {
      const currentUrl = asset.path;
      console.log(`\nProcessing: ${currentUrl}`);

      const response = await axios({
        method: 'get',
        url: currentUrl,
        responseType: 'stream'
      });

      // Split logic: grab everything after '/assets/'
      let destinationKey = currentUrl.split('/assets/')[1];
      
      if (!destinationKey) {
          destinationKey = currentUrl.split('/').pop() || 'unknown-file';
      }
      
      destinationKey = decodeURIComponent(destinationKey);

      const upload = new Upload({
        client: storageClient,
        params: {
          Bucket: BUCKET_NAME,
          Key: destinationKey,
          Body: response.data,
          ContentType: response.headers['content-type'],
        },
      });

      await upload.done();

      const newPath = `${PUBLIC_URL_BASE}/${destinationKey}`;
      
      await prisma.asset.update({
        where: { id: asset.id },
        data: { path: newPath }
      });

      console.log(`‚úÖ Migrated to: ${newPath}`);
      successCount++;

    } catch (error) {
      console.error(`‚ùå Failed to migrate asset ID ${asset.id}:`, error);
      errorCount++;
    }
  }
  
  console.log(`Migration Complete! Success: ${successCount}, Failed: ${errorCount}`);
}

migrate()
  .catch((e) => {
    console.error(e);
    process.exit(1);
  })
  .finally(async () => {
    await prisma.$disconnect();
  });

================================================
FILE: src/scripts/migrate-thumbnails.ts
================================================
/// <reference types="node" />

import { PrismaClient } from '@prisma/client';
import axios from 'axios';
import { Upload } from '@aws-sdk/lib-storage';
import { storageClient, BUCKET_NAME, PUBLIC_URL_BASE } from '../lib/storage';

const prisma = new PrismaClient();

async function migrateThumbnails() {
  console.log("üöÄ Starting THUMBNAIL Migration...");

  // 1. Find assets where the THUMBNAIL is still on Supabase
  // (Even if the main image is already on MinIO)
  const assets = await prisma.asset.findMany({
    where: {
      thumbnailPath: {
        contains: 'supabase.co' 
      }
    }
  });

  console.log(`Found ${assets.length} thumbnails to migrate.`);

  let successCount = 0;
  let errorCount = 0;

  for (const asset of assets) {
    if (!asset.thumbnailPath) continue;

    try {
      const currentUrl = asset.thumbnailPath;
      console.log(`\nProcessing Thumbnail: ${currentUrl}`);

      // 2. Download Thumbnail
      const response = await axios({
        method: 'get',
        url: currentUrl,
        responseType: 'stream'
      });

      // 3. Extract Filename
      // Thumbnails usually live in a 'thumbnails' folder or similar
      let destinationKey = currentUrl.split('/assets/')[1];
      if (!destinationKey) {
          destinationKey = currentUrl.split('/').pop() || `thumb_${asset.id}.jpg`;
      }
      destinationKey = decodeURIComponent(destinationKey);

      // 4. Upload to MinIO
      const upload = new Upload({
        client: storageClient,
        params: {
          Bucket: BUCKET_NAME,
          Key: destinationKey,
          Body: response.data,
          ContentType: response.headers['content-type'] || 'image/jpeg',
        },
      });

      await upload.done();

      // 5. Update Database
      const newPath = `${PUBLIC_URL_BASE}/${destinationKey}`;
      
      await prisma.asset.update({
        where: { id: asset.id },
        data: { thumbnailPath: newPath }
      });

      console.log(`‚úÖ Migrated to: ${newPath}`);
      successCount++;

    } catch (error) {
      console.error(`‚ùå Failed thumb ID ${asset.id}:`, error);
      errorCount++;
    }
  }
  
  console.log(`Thumbnail Migration Complete! ‚úÖ ${successCount} | ‚ùå ${errorCount}`);
}

migrateThumbnails()
  .catch((e) => {
    console.error(e);
    process.exit(1);
  })
  .finally(async () => {
    await prisma.$disconnect();
  });

================================================
FILE: src/scripts/migrate.js
================================================
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const promise_1 = __importDefault(require("mysql2/promise"));
const client_1 = require("@prisma/client");
const supabase_js_1 = require("@supabase/supabase-js");
const fs_1 = __importDefault(require("fs"));
const path_1 = __importDefault(require("path"));
const dotenv_1 = __importDefault(require("dotenv"));
const cli_progress_1 = __importDefault(require("cli-progress"));
const colors_1 = __importDefault(require("colors"));
// 1. Load Environment Variables (.env)
dotenv_1.default.config();
// --- ‚öôÔ∏è CONFIGURATION ---
const RESOURCE_SPACE_PATH = '/var/www/html/resourcespace/filestore';
const BATCH_SIZE = 50;
// --- üîå CLIENTS ---
const prisma = new client_1.PrismaClient();
// Ensure Supabase keys exist
if (!process.env.SUPABASE_URL || !process.env.SUPABASE_KEY) {
    console.error(colors_1.default.red("‚ùå Missing SUPABASE_URL or SUPABASE_KEY in .env"));
    process.exit(1);
}
const supabase = (0, supabase_js_1.createClient)(process.env.SUPABASE_URL, process.env.SUPABASE_KEY);
// MySQL Connection (Based on your config.php)
const mysqlConfig = {
    host: 'localhost',
    user: 'resourcespace_rw', // ‚úÖ Updated from your config
    password: 'your_rw_password', // ‚ö†Ô∏è MAKE SURE THIS IS THE REAL PASSWORD
    database: 'resourcespace'
};
/**
 * üïµÔ∏è‚Äç‚ôÇÔ∏è RESOURCE SPACE PATH FINDER
 * logic: ID 12345 -> Reversed "54321" -> Path "5/4/3/2/1_hash/original.jpg"
 */
function getRSFilePath(ref, extension) {
    const refStr = ref.toString();
    // Reverse the ID (Standard ResourceSpace logic)
    const reversed = refStr.split('').reverse().join('');
    // A. Build the folder path digits (Everything except the last digit)
    // Example ID 12345 -> Reverse 54321 -> Path Parts ['5', '4', '3', '2']
    const pathParts = reversed.length > 1 ? reversed.slice(0, -1).split('') : [];
    const lastDigit = reversed.slice(-1);
    // B. Walk down the directory tree
    let currentPath = RESOURCE_SPACE_PATH;
    for (const part of pathParts) {
        currentPath = path_1.default.join(currentPath, part);
        if (!fs_1.default.existsSync(currentPath))
            return null;
    }
    // C. Find the "Hashed" Folder (e.g., "1_a8f9...")
    try {
        const subdirs = fs_1.default.readdirSync(currentPath);
        // Find directory that starts with the last digit followed by underscore
        const hashedFolder = subdirs.find(d => d.startsWith(`${lastDigit}_`));
        if (!hashedFolder)
            return null;
        const fullFolderPath = path_1.default.join(currentPath, hashedFolder);
        // D. Find the Actual File
        const files = fs_1.default.readdirSync(fullFolderPath);
        const ext = extension.toLowerCase();
        // Priority search for the best quality original
        let targetFile = files.find(f => f.toLowerCase() === `original.${ext}`); // Best case
        if (!targetFile) {
            targetFile = files.find(f => f.toLowerCase() === `${ref}.${ext}`); // Fallback 1
        }
        // Fallback 2: Any file with correct extension that isn't a thumbnail
        if (!targetFile) {
            targetFile = files.find(f => f.toLowerCase().endsWith(`.${ext}`) &&
                !f.includes('_scr') &&
                !f.includes('_thm') &&
                !f.includes('_col') &&
                !f.includes('_pre'));
        }
        return targetFile ? path_1.default.join(fullFolderPath, targetFile) : null;
    }
    catch (e) {
        return null;
    }
}
async function migrate() {
    console.log(colors_1.default.cyan('\nüöÄ Starting Migration: ResourceSpace -> CapyDAM'));
    console.log(colors_1.default.gray(`   üìÇ Reading from: ${RESOURCE_SPACE_PATH}`));
    let db;
    try {
        db = await promise_1.default.createConnection(mysqlConfig);
        console.log(colors_1.default.green(`   ‚úÖ Connected to MySQL (resourcespace)`));
    }
    catch (e) {
        console.error(colors_1.default.red(`   ‚ùå MySQL Connection Failed: ${e.message}`));
        process.exit(1);
    }
    // 1. Count Resources
    const [countResult] = await db.execute('SELECT COUNT(*) as total FROM resource WHERE archive = 0');
    const totalResources = countResult[0].total;
    console.log(colors_1.default.cyan(`   üì¶ Total Active Resources: ${totalResources}\n`));
    const bar = new cli_progress_1.default.SingleBar({
        format: 'Migrating |' + colors_1.default.cyan('{bar}') + '| {percentage}% || {value}/{total} Files || ETA: {eta_formatted}',
        barCompleteChar: '\u2588',
        barIncompleteChar: '\u2591',
        hideCursor: true
    });
    bar.start(totalResources, 0);
    // 2. Get Default Admin User (Files need an owner)
    const adminUser = await prisma.user.findFirst({ where: { role: 'admin' } });
    if (!adminUser) {
        bar.stop();
        console.error(colors_1.default.red("\n‚ùå ERROR: No Admin user found in Postgres. Register an account in CapyDAM first."));
        process.exit(1);
    }
    let offset = 0;
    let successCount = 0;
    let failCount = 0;
    while (offset < totalResources) {
        const [rows] = await db.execute(`SELECT ref, title, file_extension, creation_date, field8 as description 
       FROM resource 
       WHERE archive = 0 
       ORDER BY ref ASC
       LIMIT ${BATCH_SIZE} OFFSET ${offset}`);
        for (const res of rows) {
            try {
                // --- STEP 1: FIND FILE ON DISK ---
                if (!res.file_extension) {
                    throw new Error("No file extension in DB");
                }
                const localFilePath = getRSFilePath(res.ref, res.file_extension);
                if (!localFilePath) {
                    throw new Error("File not found on disk");
                }
                // --- STEP 2: GET KEYWORDS ---
                // (Assuming standard RS keyword table structure)
                const [tagRows] = await db.execute(`SELECT k.keyword FROM resource_keyword rk 
           JOIN keyword k ON rk.keyword = k.ref 
           WHERE rk.resource = ?`, [res.ref]);
                const tags = tagRows.map((t) => t.keyword);
                // --- STEP 3: UPLOAD TO SUPABASE ---
                const fileBuffer = fs_1.default.readFileSync(localFilePath);
                const uniquePath = `migration/${res.ref}_${Date.now()}.${res.file_extension}`;
                const { error: uploadError } = await supabase.storage
                    .from('assets')
                    .upload(uniquePath, fileBuffer, {
                    contentType: `image/${res.file_extension}`,
                    upsert: false
                });
                if (uploadError)
                    throw uploadError;
                const { data: publicUrl } = supabase.storage
                    .from('assets')
                    .getPublicUrl(uniquePath);
                // --- STEP 4: INSERT TO POSTGRES ---
                const stats = fs_1.default.statSync(localFilePath);
                await prisma.asset.create({
                    data: {
                        filename: uniquePath,
                        originalName: res.title || `Resource ${res.ref}`,
                        mimeType: `image/${res.file_extension}`,
                        size: stats.size,
                        path: publicUrl.publicUrl,
                        description: res.description || '',
                        keywords: tags,
                        legacyId: res.ref,
                        userId: adminUser.id,
                        createdAt: res.creation_date ? new Date(res.creation_date) : new Date()
                    }
                });
                successCount++;
            }
            catch (err) {
                failCount++;
                fs_1.default.appendFileSync('migration_errors.log', `[${new Date().toISOString()}] ID ${res.ref}: ${err.message}\n`);
            }
            bar.increment();
        }
        offset += BATCH_SIZE;
    }
    bar.stop();
    await db.end();
    await prisma.$disconnect();
    console.log(colors_1.default.rainbow('\n‚ú® Migration Complete!'));
    console.log(colors_1.default.green(`   ‚úÖ Success: ${successCount}`));
    console.log(colors_1.default.red(`   ‚ùå Failed: ${failCount} (See migration_errors.log)`));
}
migrate().catch((e) => {
    console.error(colors_1.default.red("\nüî• Fatal Error:"), e);
    process.exit(1);
});


================================================
FILE: src/scripts/migrate.ts
================================================
import mysql from 'mysql2/promise';
import { PrismaClient } from '@prisma/client';
import { createClient } from '@supabase/supabase-js';
import fs from 'fs';
import path from 'path';
import dotenv from 'dotenv';
import cliProgress from 'cli-progress';
import colors from 'colors';

// 1. Load Environment Variables (.env)
dotenv.config();

// --- ‚öôÔ∏è CONFIGURATION ---
const RESOURCE_SPACE_PATH = '/var/www/html/resourcespace/filestore'; 
const BATCH_SIZE = 50; 

// --- üîå CLIENTS ---
const prisma = new PrismaClient();

// Ensure Supabase keys exist
if (!process.env.SUPABASE_URL || !process.env.SUPABASE_KEY) {
    console.error(colors.red("‚ùå Missing SUPABASE_URL or SUPABASE_KEY in .env"));
    process.exit(1);
}

const supabase = createClient(
  process.env.SUPABASE_URL,
  process.env.SUPABASE_KEY
);

// MySQL Connection (Based on your config.php)
const mysqlConfig = {
  host: 'localhost',      
  user: 'resourcespace_rw',  // ‚úÖ Updated from your config
  password: 'your_rw_password', // ‚ö†Ô∏è MAKE SURE THIS IS THE REAL PASSWORD
  database: 'resourcespace'
};

/**
 * üïµÔ∏è‚Äç‚ôÇÔ∏è RESOURCE SPACE PATH FINDER
 * logic: ID 12345 -> Reversed "54321" -> Path "5/4/3/2/1_hash/original.jpg"
 */
function getRSFilePath(ref: number, extension: string): string | null {
  const refStr = ref.toString();
  // Reverse the ID (Standard ResourceSpace logic)
  const reversed = refStr.split('').reverse().join('');
  
  // A. Build the folder path digits (Everything except the last digit)
  // Example ID 12345 -> Reverse 54321 -> Path Parts ['5', '4', '3', '2']
  const pathParts = reversed.length > 1 ? reversed.slice(0, -1).split('') : [];
  const lastDigit = reversed.slice(-1);

  // B. Walk down the directory tree
  let currentPath = RESOURCE_SPACE_PATH;
  for (const part of pathParts) {
    currentPath = path.join(currentPath, part);
    if (!fs.existsSync(currentPath)) return null;
  }

  // C. Find the "Hashed" Folder (e.g., "1_a8f9...")
  try {
    const subdirs = fs.readdirSync(currentPath);
    // Find directory that starts with the last digit followed by underscore
    const hashedFolder = subdirs.find(d => d.startsWith(`${lastDigit}_`));

    if (!hashedFolder) return null;

    const fullFolderPath = path.join(currentPath, hashedFolder);

    // D. Find the Actual File
    const files = fs.readdirSync(fullFolderPath);
    const ext = extension.toLowerCase();
    
    // Priority search for the best quality original
    let targetFile = files.find(f => f.toLowerCase() === `original.${ext}`); // Best case
    
    if (!targetFile) {
        targetFile = files.find(f => f.toLowerCase() === `${ref}.${ext}`); // Fallback 1
    }
    
    // Fallback 2: Any file with correct extension that isn't a thumbnail
    if (!targetFile) {
        targetFile = files.find(f => 
            f.toLowerCase().endsWith(`.${ext}`) && 
            !f.includes('_scr') && 
            !f.includes('_thm') && 
            !f.includes('_col') && 
            !f.includes('_pre')
        );
    }

    return targetFile ? path.join(fullFolderPath, targetFile) : null;

  } catch (e) {
    return null;
  }
}

async function migrate() {
  console.log(colors.cyan('\nüöÄ Starting Migration: ResourceSpace -> CapyDAM'));
  console.log(colors.gray(`   üìÇ Reading from: ${RESOURCE_SPACE_PATH}`));
  
  let db;
  try {
    db = await mysql.createConnection(mysqlConfig);
    console.log(colors.green(`   ‚úÖ Connected to MySQL (resourcespace)`));
  } catch (e: any) {
    console.error(colors.red(`   ‚ùå MySQL Connection Failed: ${e.message}`));
    process.exit(1);
  }
  
  // 1. Count Resources
  const [countResult]: any = await db.execute('SELECT COUNT(*) as total FROM resource WHERE archive = 0');
  const totalResources = countResult[0].total;
  console.log(colors.cyan(`   üì¶ Total Active Resources: ${totalResources}\n`));

  const bar = new cliProgress.SingleBar({
    format: 'Migrating |' + colors.cyan('{bar}') + '| {percentage}% || {value}/{total} Files || ETA: {eta_formatted}',
    barCompleteChar: '\u2588',
    barIncompleteChar: '\u2591',
    hideCursor: true
  });
  
  bar.start(totalResources, 0);

  // 2. Get Default Admin User (Files need an owner)
  const adminUser = await prisma.user.findFirst({ where: { role: 'admin' } });
  if (!adminUser) {
      bar.stop();
      console.error(colors.red("\n‚ùå ERROR: No Admin user found in Postgres. Register an account in CapyDAM first."));
      process.exit(1);
  }

  let offset = 0;
  let successCount = 0;
  let failCount = 0;

  while (offset < totalResources) {
    const [rows]: any = await db.execute(
      `SELECT ref, title, file_extension, creation_date, field8 as description 
       FROM resource 
       WHERE archive = 0 
       ORDER BY ref ASC
       LIMIT ${BATCH_SIZE} OFFSET ${offset}`
    );

    for (const res of rows) {
      try {
        // --- STEP 1: FIND FILE ON DISK ---
        if (!res.file_extension) { throw new Error("No file extension in DB"); }
        
        const localFilePath = getRSFilePath(res.ref, res.file_extension);
        
        if (!localFilePath) {
          throw new Error("File not found on disk");
        }

        // --- STEP 2: GET KEYWORDS ---
        // (Assuming standard RS keyword table structure)
        const [tagRows]: any = await db.execute(
          `SELECT k.keyword FROM resource_keyword rk 
           JOIN keyword k ON rk.keyword = k.ref 
           WHERE rk.resource = ?`, 
          [res.ref]
        );
        const tags = tagRows.map((t: any) => t.keyword);

        // --- STEP 3: UPLOAD TO SUPABASE ---
        const fileBuffer = fs.readFileSync(localFilePath);
        const uniquePath = `migration/${res.ref}_${Date.now()}.${res.file_extension}`;
        
        const { error: uploadError } = await supabase.storage
          .from('assets')
          .upload(uniquePath, fileBuffer, { 
              contentType: `image/${res.file_extension}`,
              upsert: false
          });

        if (uploadError) throw uploadError;

        const { data: publicUrl } = supabase.storage
          .from('assets')
          .getPublicUrl(uniquePath);

        // --- STEP 4: INSERT TO POSTGRES ---
        const stats = fs.statSync(localFilePath);
        
        await prisma.asset.create({
          data: {
            filename: uniquePath,
            originalName: res.title || `Resource ${res.ref}`,
            mimeType: `image/${res.file_extension}`, 
            size: stats.size,
            path: publicUrl.publicUrl,
            description: res.description || '',
            keywords: tags, 
            legacyId: res.ref,
            userId: adminUser.id,
            createdAt: res.creation_date ? new Date(res.creation_date) : new Date()
          }
        });

        successCount++;

      } catch (err: any) {
        failCount++;
        fs.appendFileSync('migration_errors.log', `[${new Date().toISOString()}] ID ${res.ref}: ${err.message}\n`);
      }
      
      bar.increment();
    }
    offset += BATCH_SIZE;
  }

  bar.stop();
  await db.end();
  await prisma.$disconnect();
  console.log(colors.rainbow('\n‚ú® Migration Complete!'));
  console.log(colors.green(`   ‚úÖ Success: ${successCount}`));
  console.log(colors.red(`   ‚ùå Failed: ${failCount} (See migration_errors.log)`));
}

migrate().catch((e) => {
    console.error(colors.red("\nüî• Fatal Error:"), e);
    process.exit(1);
});

================================================
FILE: src/scripts/patch-metadata.ts
================================================
import { PrismaClient } from '@prisma/client';
import mysql from 'mysql2/promise';
import dotenv from 'dotenv';

dotenv.config();

const prisma = new PrismaClient();

// ‚ö†Ô∏è OLD DATABASE CONFIG
const oldDbConfig = {
    host: 'localhost',
    user: 'resourcespace_rw',
    password: 'your_rw_password',
    database: 'resourcespace'
};

// üéØ ALL FIELD IDs
const FIELD_IDS = {
    LINK: 10,
    FILENAME: 51,
    
    // Description Candidates
    TITLE: 8,           // üëà NEW! Found this in your spy data
    DESC_CAPTION: 18,
    DESC_EXTENDED: 87,
    DESC_NOTES: 25,

    // Tags
    KEYWORDS_AI: 1,
    KEYWORDS_SUBJECT: 73,
    KEYWORDS_EVENT: 74,
    KEYWORDS_EMOTION: 75,
    KEYWORDS_RECOG: 84,
    KEYWORDS_LANDMARK: 85
};

const ALL_IDS = Object.values(FIELD_IDS);

async function patchMetadata() {
    console.log("ü©π Starting Final Patch (Including Titles as Descriptions)...");

    const oldDb = await mysql.createConnection(oldDbConfig);
    console.log("‚úÖ Connected to Old MySQL Database.");

    const assetsToFix = await prisma.asset.findMany({
        where: { filename: { startsWith: 'migration/' } },
        select: { id: true, filename: true, originalName: true, aiData: true }
    });

    console.log(`Scanning ${assetsToFix.length} migrated assets...`);
    let successCount = 0;

    const placeholders = ALL_IDS.map(() => '?').join(',');

    for (const asset of assetsToFix) {
        const match = asset.filename.match(/migration\/(\d+)_/);
        const oldId = match ? match[1] : null;

        if (!oldId) continue;

        try {
            const [rows]: any = await oldDb.execute(
                `SELECT n.resource_type_field, n.name AS value
                 FROM node n
                 JOIN resource_node rn ON n.ref = rn.node
                 WHERE rn.resource = ? 
                 AND n.resource_type_field IN (${placeholders})`,
                [oldId, ...ALL_IDS]
            );

            if (rows.length === 0) continue;

            let driveLink = null;
            let tags: string[] = [];
            
            // Description Candidates
            let valTitle = null;
            let valCaption = null;
            let valExtended = null;
            let valNotes = null;

            for (const row of rows) {
                const fieldId = row.resource_type_field;
                const val = row.value;

                if (fieldId === FIELD_IDS.LINK) driveLink = val;
                else if (fieldId === FIELD_IDS.TITLE) valTitle = val;
                else if (fieldId === FIELD_IDS.DESC_CAPTION) valCaption = val;
                else if (fieldId === FIELD_IDS.DESC_EXTENDED) valExtended = val;
                else if (fieldId === FIELD_IDS.DESC_NOTES) valNotes = val;
                else if (fieldId !== FIELD_IDS.FILENAME) {
                    if (val) {
                        const cleanParts = val.split(',').map((t: string) => t.trim()).filter((t: string) => t.length > 0);
                        tags.push(...cleanParts);
                    }
                }
            }

            // Prepare Updates
            let aiDataObj: any = {};
            try { aiDataObj = JSON.parse(asset.aiData || '{}'); } catch (e) {}
            
            let dataChanged = false;

            if (driveLink && driveLink.trim()) {
                aiDataObj.externalLink = driveLink;
                dataChanged = true;
            }

            // Waterfall: Caption -> Title -> Extended -> Notes
            // We prioritized Title because we saw it has good data!
            const bestDescription = valCaption || valTitle || valExtended || valNotes;
            
            if (bestDescription && bestDescription.trim()) {
                // Remove quotes if present (e.g. '"Title"')
                const cleanDesc = bestDescription.trim().replace(/^"|"$/g, '');
                aiDataObj.description = cleanDesc;
                aiDataObj.summary = cleanDesc;
                dataChanged = true;
            }

            if (tags.length > 0) {
                const existingTags = aiDataObj.tags || [];
                const mergedTags = [...new Set([...existingTags, ...tags])];
                aiDataObj.tags = mergedTags;
                dataChanged = true;
            }

            if (dataChanged) {
                const updates = { aiData: JSON.stringify(aiDataObj) };
                await prisma.asset.update({ where: { id: asset.id }, data: updates });
                successCount++;
                process.stdout.write(`\r‚úÖ Patched ID ${oldId}: +Desc? ${!!bestDescription} [${tags.length} Tags]`);
            }

        } catch (err: any) {
            console.error(`\n‚ùå Error processing ${oldId}: ${err.message}`);
        }
    }

    console.log(`\n\n‚ú® Patch Complete! Updated ${successCount} assets.`);
    await oldDb.end();
}

patchMetadata()
    .catch(e => console.error(e))
    .finally(async () => {
        await prisma.$disconnect();
    });


================================================
FILE: src/scripts/reset.ts
================================================
// Run this with: npx ts-node src/scripts/reset.ts
import { PrismaClient } from '@prisma/client';
import { createClient } from '@supabase/supabase-js';
import dotenv from 'dotenv';

dotenv.config();

const prisma = new PrismaClient();

// Initialize Supabase Admin Client (Needs Service Role Key for deletion)
// If you don't have SERVICE_ROLE_KEY in .env, use your SUPABASE_KEY temporarily
const supabase = createClient(
  process.env.SUPABASE_URL!,
  process.env.SUPABASE_SERVICE_ROLE_KEY || process.env.SUPABASE_KEY! 
);

const BUCKET_NAME = 'chat-attachments'; // Change this to your actual bucket name

async function main() {
  console.log('üö® STARTING NUCLEAR RESET üö®');

  // --- 1. CLEAR DATABASE ---
  console.log('\nüóëÔ∏è  Cleaning Database...');
  
  // Delete in order to avoid foreign key constraint errors
  await prisma.notification.deleteMany({});
  console.log(' - Deleted Notifications');

  await prisma.reaction.deleteMany({});
  console.log(' - Deleted Reactions');

  await prisma.message.deleteMany({});
  console.log(' - Deleted Messages');

  await prisma.membership.deleteMany({});
  console.log(' - Deleted Memberships');

  // Delete all rooms EXCEPT specific ones if you want to keep them (optional)
  // For now, we delete ALL rooms.
  await prisma.chatRoom.deleteMany({});
  console.log(' - Deleted Chat Rooms');

  
  // --- 2. CLEAR STORAGE ---
  console.log('\nüóëÔ∏è  Cleaning Supabase Storage...');
  
  try {
    // List all files in the bucket
    const { data: files, error: listError } = await supabase
      .storage
      .from(BUCKET_NAME)
      .list(undefined, { limit: 1000 });

    if (listError) {
      console.error('Error listing files:', listError.message);
    } else if (files && files.length > 0) {
      const pathsToRemove = files.map((file) => file.name);
      
      const { error: removeError } = await supabase
        .storage
        .from(BUCKET_NAME)
        .remove(pathsToRemove);

      if (removeError) {
        console.error('Error deleting files:', removeError.message);
      } else {
        console.log(` - Deleted ${files.length} files from storage`);
      }
    } else {
      console.log(' - Storage bucket is already empty');
    }
  } catch (error) {
    console.error("Storage cleanup failed (Check your Bucket Name):", error);
  }

  console.log('\n‚úÖ RESET COMPLETE. Your app is fresh.');
}

main()
  .catch((e) => console.error(e))
  .finally(async () => {
    await prisma.$disconnect();
  });

================================================
FILE: src/scripts/spy-resource.ts
================================================
import mysql from 'mysql2/promise';

const oldDbConfig = {
    host: 'localhost',
    user: 'resourcespace_rw',
    password: 'your_rw_password',
    database: 'resourcespace'
};

async function spyOnResource(resourceId: number) {
    console.log(`üïµÔ∏è‚Äç‚ôÇÔ∏è Spying on Resource ${resourceId}...`);
    const connection = await mysql.createConnection(oldDbConfig);

    try {
        // 1. Get ALL data from the Node table (V10 System)
        const [rows]: any = await connection.execute(
            `SELECT n.resource_type_field, f.title as field_name, n.name as value
             FROM node n
             JOIN resource_node rn ON n.ref = rn.node
             JOIN resource_type_field f ON n.resource_type_field = f.ref
             WHERE rn.resource = ?`,
            [resourceId]
        );

        if (rows.length === 0) {
            console.log("‚ùå No data found in 'node' table.");
        } else {
            console.table(rows);
        }

    } catch (error: any) {
        console.error("‚ùå Error:", error.message);
    } finally {
        await connection.end();
    }
}

// Spy on Resource 634 (one of the files that failed)
spyOnResource(634);


================================================
FILE: src/scripts/verify-all.ts
================================================
/// <reference types="node" />
import { PrismaClient } from '@prisma/client';

const prisma = new PrismaClient();

async function checkAll() {
  console.log("üïµÔ∏è‚Äç‚ôÇÔ∏è FINAL SYSTEM CHECK...");

  const users = await prisma.user.count({ where: { avatar: { contains: 'supabase.co' } } });
  const collections = await prisma.collection.count({ where: { coverImage: { contains: 'supabase.co' } } });
  const categories = await prisma.category.count({ where: { coverImage: { contains: 'supabase.co' } } });
  const feedback = await prisma.feedback.count({ where: { attachment: { contains: 'supabase.co' } } });
  const messages = await prisma.message.count({ where: { attachmentUrl: { contains: 'supabase.co' } } });
  
  // Check main assets again just in case
  const assets = await prisma.asset.count({ where: { path: { contains: 'supabase.co' } } });

  console.log(`\nüö® REMAINING SUPABASE LINKS:`);
  console.log(`   - Assets (Main):      ${assets}`);
  console.log(`   - Users (Avatars):    ${users}`);
  console.log(`   - Collections:        ${collections}`);
  console.log(`   - Categories:         ${categories}`);
  console.log(`   - Feedback:           ${feedback}`);
  console.log(`   - Chat Messages:      ${messages}`);

  if (users + collections + categories + feedback + messages + assets === 0) {
    console.log(`\nüéâ CONGRATULATIONS! YOUR DATABASE IS 100% SUPABASE-FREE.`);
  } else {
    console.log(`\n‚ö†Ô∏è Some files remain. Run the migration scripts again.`);
  }
}

checkAll()
  .catch(console.error)
  .finally(() => prisma.$disconnect());


================================================
FILE: src/scripts/verify-migration.ts
================================================
/// <reference types="node" />
import { PrismaClient } from '@prisma/client';

const prisma = new PrismaClient();
const NEW_DOMAIN = 'storage.capy-dev.com';

async function verifyMigration() {
  console.log("üïµÔ∏è‚Äç‚ôÇÔ∏è Running Deep Verification...");

  const assets = await prisma.asset.findMany({
    where: { mimeType: { startsWith: 'video/' } },
    select: { id: true, previewFrames: true }
  });

  let valid = 0;
  let stillSupabase = 0;
  let empty = 0;
  let weird = 0;
  const samples: any[] = [];

  for (const asset of assets) {
    const frames = asset.previewFrames || [];

    if (frames.length === 0) {
      empty++;
      continue;
    }

    // Check the first frame to determine status
    const firstFrame = frames[0];

    if (firstFrame.includes(NEW_DOMAIN)) {
      valid++;
      // Save 5 random samples to show the user
      if (samples.length < 5) samples.push({ id: asset.id, url: firstFrame });
    } else if (firstFrame.includes('supabase.co')) {
      stillSupabase++;
    } else {
      weird++; // Neither Supabase nor Capy-Dev (Could be broken or relative path)
    }
  }

  console.log(`\nüìä FINAL STATS:`);
  console.log(`--------------------------------`);
  console.log(`‚úÖ Migrated (Capy-Dev): ${valid}`);
  console.log(`‚ùå Pending (Supabase):  ${stillSupabase}`);
  console.log(`‚ö†Ô∏è Empty/No Previews:   ${empty}`);
  console.log(`‚ùì Unknown/Weird:       ${weird}`);
  console.log(`--------------------------------`);
  console.log(`TOTAL VIDEOS:           ${assets.length}`);

  console.log(`\nüîé SAMPLING 5 RANDOM MIGRATED FILES:`);
  samples.forEach(s => {
    console.log(`   ID: ${s.id}`);
    console.log(`   URL: ${s.url}`); // Check this line carefully!
    console.log(`   ---`);
  });
}

verifyMigration()
  .catch(console.error)
  .finally(() => prisma.$disconnect());


================================================
FILE: src/services/ai.service.ts
================================================
import fs from 'fs-extra';
import OpenAI from 'openai';
import path from 'path';
import { prisma } from '../lib/prisma';
import ffmpeg from 'fluent-ffmpeg';
import os from 'os';

// --- 1. DYNAMIC CONFIGURATION ---
const platform = os.platform();

if (platform === 'linux') {
    // PRODUCTION (VPS)
    console.log('üêß Linux detected: Using system FFmpeg');
    ffmpeg.setFfmpegPath('/usr/bin/ffmpeg');
    ffmpeg.setFfprobePath('/usr/bin/ffprobe');
} else {
    // LOCAL (Windows/Mac)
    console.log('üíª Local OS detected: Using static FFmpeg');
    try {
        const ffmpegPath = require('ffmpeg-static');
        const ffprobePath = require('ffprobe-static').path;
        if (ffmpegPath) ffmpeg.setFfmpegPath(ffmpegPath);
        if (ffprobePath) ffmpeg.setFfprobePath(ffprobePath);
    } catch (e) {
        console.warn("‚ö†Ô∏è Could not load static ffmpeg/ffprobe.");
    }
}

const pdfParse = require('pdf-extraction'); 

const openai = new OpenAI({
  apiKey: process.env.OPENAI_API_KEY,
  timeout: 90 * 1000, 
  maxRetries: 2,
});

const VALID_COLORS = "Red, Orange, Yellow, Green, Teal, Blue, Purple, Pink, Black, White, Gray";

interface AiOptions {
  creativity: number;
  specificity: string;
}

// --- 2. SYSTEM PROMPTS (Instructional Design Specialized) ---

const IMAGE_SYSTEM_PROMPT = `You are an expert Visual Analyst for Instructional Design.
Your goal is to categorize assets for use in e-learning courses (Storyline, Rise, Captivate).
COLORS: Use ONLY [${VALID_COLORS}].`;

const VIDEO_SYSTEM_PROMPT = `You are an expert Video Content Analyst for E-Learning.
Your goal is to describe the instructional value, pacing, and content of videos/GIFs.
COLORS: Use ONLY [${VALID_COLORS}].`;

// --- 3. SEARCH EXPANSION ---
const queryCache = new Map<string, { terms: string[], expires: number }>();

export const expandQuery = async (term: string): Promise<string[]> => {
  const cached = queryCache.get(term);
  if (cached && cached.expires > Date.now()) return cached.terms;

  try {
    const response = await openai.chat.completions.create({
      model: "gpt-4o-mini",
      temperature: 0.3,
      messages: [{
        role: "user",
        content: `Given search term "${term}" in an EdTech context, return JSON with 'terms' array (3-5 synonyms). Example: "tutorial" -> ["walkthrough", "demonstration", "guide"].`
      }],
      response_format: { type: "json_object" }
    });
    
    const data = JSON.parse(response.choices[0].message.content || '{}');
    const results = [term, ...(data.terms || [])]; 
    queryCache.set(term, { terms: results, expires: Date.now() + (24 * 60 * 60 * 1000) });
    return results;
  } catch (e) { return [term]; }
};

// --- 4. EMBEDDINGS ---
export const generateEmbedding = async (text: string) => {
  try {
    const cleanText = text.replace(/\n/g, ' ').slice(0, 8000);
    const response = await openai.embeddings.create({
      model: "text-embedding-3-small",
      input: cleanText,
      encoding_format: "float",
    });
    return response.data[0].embedding;
  } catch (error) { return null; }
};

// --- 5. DB HELPERS ---
const saveAiData = async (id: string, data: any) => {
  // Combine all text fields for the vector embedding
  const textToEmbed = `${data.description || ''} ${data.tags?.join(', ') || ''} ${data.educationalContext || ''} ${data.transcript || ''}`;
  const embedding = await generateEmbedding(textToEmbed);

  if (embedding) {
    await prisma.asset.update({ where: { id }, data: { aiData: JSON.stringify(data) } });
    const vectorString = `[${embedding.join(',')}]`;
    await prisma.$executeRaw`UPDATE "Asset" SET embedding = ${vectorString}::vector WHERE id = ${id}`;
  } else {
    await prisma.asset.update({ where: { id }, data: { aiData: JSON.stringify(data) } });
  }
};

const extractKeyFrames = async (videoPath: string): Promise<string[]> => {
  const screenshots: string[] = [];
  const absoluteVideoPath = path.resolve(videoPath);

  const duration = await new Promise<number>((resolve, reject) => {
    ffmpeg.ffprobe(absoluteVideoPath, (err, metadata) => {
      if (err) return reject(err);
      const d = parseFloat(metadata.format.duration as any);
      resolve(isNaN(d) ? 0 : d);
    });
  });

  let timestamps: number[] = [];
  if (duration > 0) {
      // Extract more frames if video is long
      if (duration > 60) timestamps = [duration * 0.1, duration * 0.5, duration * 0.9];
      else timestamps = [duration * 0.2, duration * 0.8];
  } else {
      timestamps = [0]; 
  }

  for (let i = 0; i < timestamps.length; i++) {
    const filename = `frame-${i}-${Date.now()}.jpg`;
    const outPath = path.join(path.dirname(absoluteVideoPath), filename);
    await new Promise((resolve, reject) => {
      ffmpeg(absoluteVideoPath)
        .screenshots({ timestamps: [timestamps[i]], filename, folder: path.dirname(absoluteVideoPath), size: '400x?' })
        .on('end', resolve)
        .on('error', reject);
    });
    screenshots.push(outPath);
  }
  return screenshots;
};

const encodeImage = async (p: string) => (await fs.readFile(p)).toString('base64');

// --- 6. ANALYZERS ---

// A. IMAGE (With Slider Logic)
export const analyzeImage = async (assetId: string, filePath: string, options?: AiOptions) => {
  try {
    const base64Image = await encodeImage(filePath);
    const isSpecific = options?.specificity === 'high';
    
    const userPrompt = isSpecific 
      ? `Analyze this image in high detail for e-learning use.
         Return JSON:
         1. 'tags': 20-25 precise keywords (Objects, Style, Technical).
         2. 'description': Detailed breakdown of composition and utility.
         3. 'colors': 3 standard color names.
         4. 'educationalContext': "How can this be used in training?"
         5. 'storylineUseCase': "Specific slide suggestion (e.g. 'Background', 'Character')."`
      : `Analyze this image generally.
         Return JSON:
         1. 'tags': 8-10 broad categories.
         2. 'description': Brief summary.
         3. 'colors': 3 standard color names.`;

    const response = await openai.chat.completions.create({
      model: "gpt-4o-mini",
      // SLIDER CONNECTED HERE: 0.0 (Robot) -> 1.0 (Creative)
      temperature: options?.creativity || 0.4, 
      messages: [
        { role: "system", content: IMAGE_SYSTEM_PROMPT },
        { role: "user", content: [
            { type: "text", text: userPrompt },
            { type: "image_url", image_url: { url: `data:image/jpeg;base64,${base64Image}` } }
          ]
        }
      ],
      response_format: { type: "json_object" },
    });
    
    const aiData = JSON.parse(response.choices[0].message.content || '{}');
    aiData.assetType = 'image';
    await saveAiData(assetId, aiData);
    console.log(`‚úÖ Image Analysis complete (Spec: ${options?.specificity}, Temp: ${options?.creativity})`);
    
    // 2. ‚úÖ ADD THIS: Return the data so our script can use the tags
    return aiData;
    
  } catch (e) { 
    console.error(e);  
    return null; // Return null on failure
  }
};

// B. PDF
export const analyzePdf = async (assetId: string, filePath: string, options?: AiOptions) => {
  try {
    const dataBuffer = await fs.readFile(filePath);
    const data = await pdfParse(dataBuffer);
    const textSample = data.text.slice(0, 12000);
    
    const response = await openai.chat.completions.create({
        model: "gpt-4o-mini",
        temperature: options?.creativity || 0.2,
        messages: [
            { role: "system", content: "You are an Instructional Design Archivist." },
            { role: "user", content: `Analyze this document text. Return JSON: { "tags": [], "description": "Summary", "educationalContext": "Topic" }\n\n${textSample}` }
        ],
        response_format: { type: "json_object" }
    });
    const aiData = JSON.parse(response.choices[0].message.content || '{}');
    aiData.assetType = 'document';
    await saveAiData(assetId, aiData);
    console.log(`‚úÖ PDF Analysis complete`);
  } catch (e) { console.error(e); }
};

// C. VIDEO / GIF (With Slider Logic)
export const analyzeAudioVideo = async (assetId: string, filePath: string, options?: AiOptions) => {
  try {
    const absolutePath = path.resolve(filePath);
    const stats = await fs.stat(absolutePath);
    const ext = path.extname(absolutePath).toLowerCase();
    
    const isVideo = ['.mp4', '.mov', '.avi', '.mkv', '.webm', '.gif'].includes(ext);

    if (isVideo) {
      console.log(`üé• Starting Motion Analysis for: ${assetId}`);
      
      let transcript = "";
      const isGif = ext === '.gif';

      if (!isGif && stats.size < 25 * 1024 * 1024) {
         try {
           const transcription = await openai.audio.transcriptions.create({
             file: fs.createReadStream(absolutePath),
             model: "whisper-1",
           });
           transcript = transcription.text;
         } catch (e) { /* ignore */ }
      } else if (isGif) {
          transcript = "[Animated GIF - Visuals Only]";
      }

      const framePaths = await extractKeyFrames(absolutePath);
      const imageContents = await Promise.all(framePaths.map(async (p) => ({
        type: "image_url",
        image_url: { url: `data:image/jpeg;base64,${await encodeImage(p)}` }
      })));

      const isSpecific = options?.specificity === 'high';
      const userPrompt = isSpecific
        ? `Analyze these frames + transcript in DEPTH.
           Return JSON:
           1. 'tags': 20+ keywords (Action, Software, Instructional method).
           2. 'description': Detailed step-by-step or narrative summary.
           3. 'colors': 3 standard names.
           4. 'instructionalApproach': (e.g. "Demo", "Scenario").`
        : `Analyze these frames + transcript GENERALLY.
           Return JSON:
           1. 'tags': 8-10 broad topics.
           2. 'description': Brief summary.
           3. 'colors': 3 names.`;

      const response = await openai.chat.completions.create({
        model: "gpt-4o-mini",
        // SLIDER CONNECTED HERE
        temperature: options?.creativity || 0.3,
        messages: [
          { role: "system", content: VIDEO_SYSTEM_PROMPT },
          { role: "user", content: [
              { type: "text", text: `Context: Transcript: "${transcript.slice(0, 2000)}"\n${userPrompt}` },
              ...imageContents as any
            ]
          }
        ],
        response_format: { type: "json_object" },
      });

      let aiData = JSON.parse(response.choices[0].message.content || '{}');
      
      // Flatten frames if AI gets confused
      if (aiData.frames) {
          aiData.tags = aiData.frames.flatMap((f:any) => f.tags);
          aiData.description = aiData.frames.map((f:any) => f.description).join(' ');
          delete aiData.frames;
      }

      aiData.isVideoAnalysis = true;
      aiData.transcript = transcript; 

      await saveAiData(assetId, aiData);
      await Promise.all(framePaths.map(p => fs.remove(p)));
      console.log(`‚úÖ Motion Analysis complete`);

    }
  } catch (e) { console.error(`AV Analysis failed`, e); }
};

================================================
FILE: src/services/cron.service.ts
================================================
import cron from 'node-cron';
import { PrismaClient } from '@prisma/client';
import { deleteFromSupabase } from '../utils/supabase'; // Adjust path to your supabase helper
import path from 'path';

const prisma = new PrismaClient();

const EXPIRATION_DAYS = 30;

export const initCronJobs = () => {
  // ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ second (optional)
  // ‚îÇ ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ minute
  // ‚îÇ ‚îÇ ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ hour
  // ‚îÇ ‚îÇ ‚îÇ ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ day of month
  // ‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ month
  // ‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îå‚îÄ‚îÄ‚îÄ‚îÄ day of week
  // ‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îÇ
  // * * * * * *
  
  // Schedule: Run every day at Midnight (00:00)
  cron.schedule('0 0 * * *', async () => {
    console.log('‚è∞ [CRON] Running scheduled cleanup for expired trash...');
    await cleanupExpiredAssets();
  });
  
  console.log('‚úÖ Cron jobs initialized');
};

const cleanupExpiredAssets = async () => {
  try {
    // 1. Calculate the cutoff date (30 days ago)
    const cutoffDate = new Date();
    cutoffDate.setDate(cutoffDate.getDate() - EXPIRATION_DAYS);

    // 2. Find assets that were deleted BEFORE the cutoff date
    const expiredAssets = await prisma.asset.findMany({
      where: {
        deletedAt: {
          lt: cutoffDate, // "Less than" means older than the date
          not: null
        }
      }
    });

    if (expiredAssets.length === 0) {
      console.log('‚ú® [CRON] No expired assets found.');
      return;
    }

    console.log(`üóëÔ∏è [CRON] Found ${expiredAssets.length} assets older than ${EXPIRATION_DAYS} days. Deleting permanently...`);

    // 3. Delete Files from Storage (Supabase)
    // We process this sequentially or in parallel chunks to avoid overwhelming the network
    for (const asset of expiredAssets) {
      try {
        // Delete Main File
        if (asset.path) await deleteFromSupabase(asset.path);
        
        // Delete Thumbnail
        if (asset.thumbnailPath) await deleteFromSupabase(asset.thumbnailPath);
        
        // Delete Preview Frames (Video)
        if (asset.previewFrames && asset.previewFrames.length > 0) {
           await Promise.all(asset.previewFrames.map(frame => deleteFromSupabase(frame)));
        }
      } catch (err) {
        console.error(`‚ö†Ô∏è [CRON] Failed to delete files for asset ${asset.id}`, err);
        // We continue anyway to ensure the DB record gets cleaned up
      }
    }

    // 4. Delete Database Records
    const assetIds = expiredAssets.map(a => a.id);

    // Clean up relations first (if cascade isn't set in DB)
    await prisma.$transaction([
        prisma.assetClick.deleteMany({ where: { assetId: { in: assetIds } } }),
        prisma.assetOnCategory.deleteMany({ where: { assetId: { in: assetIds } } }),
        prisma.assetOnCollection.deleteMany({ where: { assetId: { in: assetIds } } }),
        prisma.asset.deleteMany({ where: { id: { in: assetIds } } })
    ]);

    console.log(`‚úÖ [CRON] Successfully permanently deleted ${expiredAssets.length} assets.`);

  } catch (error) {
    console.error('üî• [CRON] Critical error during cleanup:', error);
  }
};

================================================
FILE: src/services/image.service.ts
================================================
import sharp from 'sharp';
import fs from 'fs-extra';
import path from 'path';
import ffmpeg from 'fluent-ffmpeg';
import os from 'os';

// --- DYNAMIC PATH CONFIGURATION ---
const platform = os.platform();

if (platform === 'linux') {
    // PRODUCTION (Linux VPS)
    ffmpeg.setFfmpegPath('/usr/bin/ffmpeg');
} else {
    // LOCAL DEV (Windows)
    try {
        const ffmpegPath = require('ffmpeg-static');
        if (ffmpegPath) ffmpeg.setFfmpegPath(ffmpegPath);
    } catch (e) {
        console.warn("Could not load static ffmpeg for thumbnails.");
    }
}

// 1. IMAGES (Smart: Handles Static & Animated)
export const generateThumbnail = async (filePath: string, outputDir: string): Promise<string> => {
  const fileName = path.basename(filePath);
  const ext = path.extname(filePath).toLowerCase();
  const nameWithoutExt = path.parse(fileName).name; 

  // A. Handle GIFs (Animated WebP)
  if (ext === '.gif') {
      const thumbnailFilename = `thumb_${nameWithoutExt}.webp`;
      const thumbnailPath = path.join(outputDir, thumbnailFilename);

      await sharp(filePath, { animated: true }) // <--- Enable Animation
        .resize({ width: 400 })
        .webp({ quality: 80, effort: 4 }) // <--- Save as WebP (Better than GIF)
        .toFile(thumbnailPath);

      return `thumbnails/${thumbnailFilename}`;
  }

  // B. Handle Static Images (JPEG)
  const thumbnailFilename = `thumb_${nameWithoutExt}.jpg`;
  const thumbnailPath = path.join(outputDir, thumbnailFilename);

  await sharp(filePath)
    .resize({ width: 400 }) 
    .jpeg({ quality: 80 })
    .toFile(thumbnailPath);

  return `thumbnails/${thumbnailFilename}`;
};

// 2. VIDEOS
export const generateVideoThumbnail = async (filePath: string, outputDir: string): Promise<string> => {
  return new Promise((resolve, reject) => {
    const fileName = path.basename(filePath);
    const nameWithoutExt = path.parse(fileName).name;
    const thumbnailFilename = `thumb_${nameWithoutExt}.jpg`;
    
    ffmpeg(filePath)
      .screenshots({
        timestamps: ['20%'], 
        filename: thumbnailFilename,
        folder: outputDir,
        size: '400x?',
      })
      .on('end', () => resolve(`thumbnails/${thumbnailFilename}`))
      .on('error', (err) => reject(err));
  });
};

// 3. PDFS
export const generatePdfThumbnail = async (filePath: string, outputDir: string): Promise<string | null> => {
  return null; // Return null -> Frontend shows Icon
};

// ‚úÖ ADD THIS NEW FUNCTION
export const generateVideoPreviews = (videoPath: string, outputDir: string, filenameBase: string): Promise<string[]> => {
  return new Promise((resolve, reject) => {
    const filenames: string[] = [];
    
    ffmpeg(videoPath)
      .on('filenames', (fnames) => {
        // fluent-ffmpeg returns an array of filenames
        fnames.forEach((f) => filenames.push(f));
      })
      .on('end', () => {
        resolve(filenames);
      })
      .on('error', (err) => {
        console.error('FFmpeg error:', err);
        reject(err);
      })
      .screenshots({
        count: 10,             // üì∏ Take 10 snapshots
        folder: outputDir,
        filename: `${filenameBase}-scrub-%i.jpg`,
        size: '320x?',         // Small size for fast loading
      });
  });
};

================================================
FILE: src/services/storage.service.ts
================================================
import fs from 'fs-extra';
import { PutObjectCommand, DeleteObjectCommand } from '@aws-sdk/client-s3';

// Import the client we just created in src/lib/storage.ts
import { storageClient, BUCKET_NAME, PUBLIC_URL_BASE } from '../lib/storage';

/**
 * UPLOADS a file to your Self-Hosted MinIO Server.
 * * NOTE: The function name is kept as 'uploadToSupabase' so we don't 
 * have to rewrite your entire Asset Controller. It now points to MinIO.
 */
export const uploadToSupabase = async (
  localFilePath: string, 
  destinationPath: string, 
  mimeType: string
): Promise<string> => {
  try {
    // 1. Read file from local disk
    const fileBuffer = await fs.readFile(localFilePath);

    // 2. Upload to MinIO (S3 Compatible)
    await storageClient.send(new PutObjectCommand({
      Bucket: BUCKET_NAME,
      Key: destinationPath, // e.g., "originals/my-photo.jpg"
      Body: fileBuffer,
      ContentType: mimeType,
      // ACL: 'public-read' // Optional: Depends on your bucket policy
    }));

    // 3. Return the Public URL
    // Result: https://storage.capy-dev.com/capydam-assets/originals/my-photo.jpg
    // This string is what gets saved into your Prisma Database.
    return `${PUBLIC_URL_BASE}/${destinationPath}`;

  } catch (error) {
    console.error('‚ùå Storage Upload Error:', error);
    throw new Error('Failed to upload to cloud storage');
  }
};

/**
 * DELETES a file from MinIO.
 */
export const deleteFromSupabase = async (pathUrl: string): Promise<void> => {
  try {
    // 1. Extract the file key (relative path) from the full URL
    // Example Input: https://storage.capy-dev.com/capydam-assets/originals/image.jpg
    // We need just: "originals/image.jpg"
    let fileKey = pathUrl;
    
    // Split by the bucket name to find the relative part
    if (pathUrl.includes(`${BUCKET_NAME}/`)) {
      const parts = pathUrl.split(`${BUCKET_NAME}/`);
      if (parts.length > 1) {
        fileKey = parts[1];
      }
    }

    // 2. Send Delete Command
    await storageClient.send(new DeleteObjectCommand({
      Bucket: BUCKET_NAME,
      Key: fileKey,
    }));

  } catch (error) {
    console.error('‚ö†Ô∏è Storage Delete Error:', error);
    // We do NOT throw an error here, so the controller keeps running 
    // even if the file was already missing.
  }
};

================================================
FILE: src/socket/socketHandler.ts
================================================
import { Server, Socket } from 'socket.io';
import { prisma } from '../lib/prisma'; 

// --- TYPES ---
interface SocketUser {
    userId: string;
    name: string;
    avatar?: string;
}

// Global Online Users Map
const onlineUsers = new Map<string, SocketUser>(); // Key: SocketID, Value: UserData

export const setupSocketIO = (io: Server) => {
    console.log("‚úÖ [Socket] System Initialized (v4 - Complete)");

    io.on('connection', (socket: Socket) => {
        

            // --- 0. FETCH ALL USERS (Directory) ---
            socket.on('fetch_all_users', async () => {
                try {
                    const users = await prisma.user.findMany({
                        select: { id: true, name: true, avatar: true },
                        orderBy: { name: 'asc' }
                    });
                    socket.emit('receive_all_users', users);
                } catch (e) {
                    console.error("‚ùå Fetch Users Error:", e);
                }
            });
        // --- 1. REGISTRATION & AUTO-JOIN ---
        socket.on('register_user', async (user: SocketUser) => {
            console.log(`üîå Connected: ${user.name} (${user.userId})`);
            
            // 1. Attach Data
            socket.data.userId = user.userId;
            socket.data.name = user.name;
            onlineUsers.set(socket.id, user);

            // 2. Join Personal Room (for private notifs)
            socket.join(user.userId);

            // 3. Auto-Join ALL existing Rooms (Channels, Groups, DMs)
            try {
                // Find all rooms where this user has a membership (DMs, Private Groups)
                const myRooms = await prisma.chatRoom.findMany({
                    where: {
                        memberships: { some: { userId: user.userId } }
                    },
                    select: { id: true }
                });

                // Find ALL public channels (Type: 'global')
                // We force-join everyone to global channels so they get updates instantly
                const publicRooms = await prisma.chatRoom.findMany({
                    where: { type: 'global' },
                    select: { id: true }
                });

                // Combine IDs (Deduplicated)
                const allRoomIds = new Set([...myRooms.map(r => r.id), ...publicRooms.map(r => r.id)]);

                // Force Socket Join
                allRoomIds.forEach(roomId => {
                    socket.join(roomId);
                });
                
                console.log(`üìÇ Auto-joined ${allRoomIds.size} rooms for ${user.name}`);

                // 4. Send Initial Data to Client
                io.emit('update_online_users', Array.from(onlineUsers.values()));
                
                // Send list of rooms to frontend so it can render the sidebar
                const fullRooms = await prisma.chatRoom.findMany({
                    where: { id: { in: Array.from(allRoomIds) } },
                    include: {
                        memberships: {
                            include: { user: { select: { id: true, name: true, avatar: true } } }
                        },
                        // Get last message for snippets/sorting
                        messages: {
                            take: 1,
                            orderBy: { createdAt: 'desc' },
                            select: { content: true, createdAt: true }
                        }
                    },
                    orderBy: { createdAt: 'asc' } // Keep channels stable
                });
                
                socket.emit('sync_room_list', fullRooms);

            } catch (e) {
                console.error("‚ùå Auto-Join Error:", e);
            }
        });

        // --- 2. CREATE PUBLIC CHANNEL ---
        socket.on('create_channel', async (name: string) => {
            // Sanitize: "General Chat" -> "general-chat"
            const safeName = name.trim().toLowerCase().replace(/\s+/g, '-');
            if (!safeName) return;

            console.log(`üì¢ Creating Channel: #${safeName}`);

            try {
                // 1. Check if exists
                const existing = await prisma.chatRoom.findFirst({
                    where: { name: safeName, type: 'global' }
                });

                if (existing) return; 

                // 2. Create in DB
                const newRoom = await prisma.chatRoom.create({
                    data: {
                        name: safeName,
                        type: 'global' // Marks it as public
                    },
                    include: {
                        memberships: { include: { user: true } },
                        messages: { take: 1 }
                    }
                });

                // 3. Make EVERYONE join this new room immediately
                const allSockets = await io.fetchSockets();
                for (const s of allSockets) {
                    s.join(newRoom.id);
                }

                // 4. Broadcast to frontend to update sidebar
                io.emit('room_created', newRoom);

            } catch (e) {
                console.error("‚ùå Create Channel Error:", e);
            }
        });

        // --- 2.6 DELETE ROOM (Channels or Groups) ---
        socket.on('delete_room', async (roomId: string) => {
            const userId = socket.data.userId;
            if (!userId || !roomId) return;

            try {
                // 1. Check permissions (Must be ADMIN)
                // Note: For public channels, you might want to restrict this to system admins
                // For now, we allow the creator (who gets ADMIN role) to delete.
                
                // First, check if user is a member/admin
                const membership = await prisma.membership.findUnique({
                    where: { userId_roomId: { userId, roomId } }
                });

                // Allow if ADMIN (for groups) or maybe implement specific logic for global channels
                // For simplicity: specific global channel checks can be added here
                if (membership?.role !== 'ADMIN') {
                     // If it's a global channel, maybe check if user is a system admin?
                     // For this demo, we will assume only room ADMINs can delete.
                     return;
                }

                // 2. Delete the Room
                await prisma.chatRoom.delete({
                    where: { id: roomId }
                });

                // 3. Broadcast Deletion (Remove from everyone's sidebar)
                io.emit('room_deleted', roomId);

            } catch (e) {
                console.error("‚ùå Delete Room Error:", e);
            }
        });

        // --- 3. CREATE PRIVATE GROUP ---
        socket.on('create_group', async (data: { name: string }) => {
            const senderId = socket.data.userId;
            if (!senderId || !data.name) return;

            try {
                const newGroup = await prisma.chatRoom.create({
                    data: {
                        name: data.name,
                        type: 'group',
                        memberships: {
                            create: { userId: senderId, role: 'ADMIN' }
                        }
                    },
                    include: {
                        memberships: { include: { user: true } },
                        messages: { take: 1 }
                    }
                });

                socket.join(newGroup.id);
                socket.emit('room_created', newGroup); // Only sender sees it initially
            } catch (e) {
                console.error("‚ùå Create Group Error:", e);
            }
        });

        // --- 3.5 ADD MEMBER TO GROUP ---
        socket.on('add_member', async (data: { roomId: string, targetUserId: string }) => {
            const senderId = socket.data.userId;
            if (!senderId || !data.roomId || !data.targetUserId) return;

            try {
                // 1. Verify Sender Permission
                const senderMembership = await prisma.membership.findUnique({
                    where: { userId_roomId: { userId: senderId, roomId: data.roomId } }
                });
                if (!senderMembership) return;

                // 2. Check if Target is ALREADY in the group
                const existing = await prisma.membership.findUnique({
                    where: { userId_roomId: { userId: data.targetUserId, roomId: data.roomId } }
                });
                if (existing) return;

                // 3. Get Target User Details
                const targetUser = await prisma.user.findUnique({ 
                    where: { id: data.targetUserId },
                    select: { name: true }
                });
                const targetName = targetUser?.name || 'Unknown User';

                // 4. Create Membership
                await prisma.membership.create({
                    data: { userId: data.targetUserId, roomId: data.roomId, role: 'MEMBER' }
                });

                // 5. Force Target Socket to Join
                const targetSocketEntry = Array.from(onlineUsers.entries()).find(([, u]) => u.userId === data.targetUserId);
                if (targetSocketEntry) {
                    const [targetSocketId] = targetSocketEntry;
                    const targetSocket = io.sockets.sockets.get(targetSocketId);
                    if (targetSocket) {
                        targetSocket.join(data.roomId);
                        // Fetch room data to push to their sidebar
                        const roomData = await prisma.chatRoom.findUnique({
                            where: { id: data.roomId },
                            include: {
                                memberships: { include: { user: true } },
                                messages: { take: 1, orderBy: { createdAt: 'desc' } }
                            }
                        });
                        if (roomData) targetSocket.emit('room_created', roomData);
                    }
                }

                // 6. Create System Message
                const sysMsg = await prisma.message.create({
                    data: {
                        content: `${socket.data.name} added ${targetName} to the group.`,
                        userId: senderId, 
                        roomId: data.roomId,
                        attachmentType: 'system'
                    },
                    include: { user: { select: { id: true, name: true, avatar: true } } }
                });

                // 7. Broadcast update
                io.to(data.roomId).emit('receive_message', sysMsg);

            } catch (e) {
                console.error("‚ùå Add Member Error:", e);
            }
        });


        // --- 3.6 KICK MEMBER ---
        socket.on('kick_member', async (data: { roomId: string, targetUserId: string }) => {
            const senderId = socket.data.userId;
            if (!senderId || !data.roomId || !data.targetUserId) return;

            try {
                // 1. Verify Requester is ADMIN
                const requesterMembership = await prisma.membership.findUnique({
                    where: { userId_roomId: { userId: senderId, roomId: data.roomId } }
                });

                if (requesterMembership?.role !== 'ADMIN') return; 

                // 2. Get Target Name
                const targetUser = await prisma.user.findUnique({ where: { id: data.targetUserId } });
                const targetName = targetUser?.name || 'User';

                // 3. Delete Membership
                await prisma.membership.delete({
                    where: { userId_roomId: { userId: data.targetUserId, roomId: data.roomId } }
                });

                // 4. Handle Target Socket (If Online)
                const targetSocketEntry = Array.from(onlineUsers.entries()).find(([, u]) => u.userId === data.targetUserId);
                if (targetSocketEntry) {
                    const [targetSocketId] = targetSocketEntry;
                    const targetSocket = io.sockets.sockets.get(targetSocketId);
                    if (targetSocket) {
                        targetSocket.leave(data.roomId);
                        targetSocket.emit('kicked_from_room', data.roomId);
                    }
                }

                // 5. System Message
                const sysMsg = await prisma.message.create({
                    data: {
                        content: `${socket.data.name} removed ${targetName} from the group.`,
                        userId: senderId,
                        roomId: data.roomId,
                        attachmentType: 'system'
                    },
                    include: { user: true }
                });
                io.to(data.roomId).emit('receive_message', sysMsg);

                // 6. Broadcast Member List Update
                const updatedRoom = await prisma.chatRoom.findUnique({
                    where: { id: data.roomId },
                    include: {
                        memberships: { include: { user: true } },
                        messages: { take: 1, orderBy: { createdAt: 'desc' } }
                    }
                });
                if (updatedRoom) {
                    io.to(data.roomId).emit('room_updated', updatedRoom);
                }

            } catch (e) {
                console.error("‚ùå Kick Member Error:", e);
            }
        });

        // --- 4. MESSAGING (STRICT UUID) ---
        socket.on('send_message', async (data: { content: string, roomId: string, attachmentUrl?: string, attachmentType?: string, attachmentName?: string }) => {
            const senderId = socket.data.userId;
            if (!senderId) return;

            try {
                // 1. Create Message
                const message = await prisma.message.create({
                    data: {
                        content: data.content,
                        userId: senderId,
                        roomId: data.roomId,
                        attachmentUrl: data.attachmentUrl,
                        attachmentType: data.attachmentType,
                        attachmentName: data.attachmentName
                    },
                    include: {
                        user: { select: { id: true, name: true, avatar: true } },
                        reactions: true
                    }
                });

                // 2. Broadcast to Room UUID
                io.to(data.roomId).emit('receive_message', message);

                // 3. Mentions
                const mentionRegex = /@(\w+)/g; 
                const matches = data.content.match(mentionRegex);
                if (matches) {
                    for (const match of matches) {
                        const name = match.substring(1);
                        const target = await prisma.user.findFirst({ where: { name: { equals: name, mode: 'insensitive' } } });
                        if (target) {
                            io.to(target.id).emit('receive_notification', {
                                id: crypto.randomUUID(), 
                                text: `Mentioned you in a message`,
                                senderName: socket.data.name,
                                roomId: data.roomId,
                                roomName: 'chat',
                                createdAt: new Date().toISOString(),
                                read: false
                            });
                        }
                    }
                }

            } catch (e) {
                console.error("‚ùå Send Error:", e);
            }
        });

        // --- 4.5 EDIT MESSAGE (NEW) ---
        socket.on('edit_message', async (data: { messageId: string, newContent: string, roomId: string }) => {
            const senderId = socket.data.userId;
            if (!senderId || !data.messageId || !data.newContent) return;

            try {
                const existing = await prisma.message.findUnique({ where: { id: data.messageId } });
                if (!existing || existing.userId !== senderId) return;

                const updatedMessage = await prisma.message.update({
                    where: { id: data.messageId },
                    data: { 
                        content: data.newContent,
                        // Note: Ensure your Prisma schema has an updatedAt field or handled automatically
                    },
                    include: {
                        user: { select: { id: true, name: true, avatar: true } },
                        reactions: true
                    }
                });

                // Manually inject 'updatedAt' flag if schema doesn't auto-handle it effectively for the UI check
                // or just rely on the 'updatedAt' timestamp from DB
                
                io.to(data.roomId).emit('message_updated', updatedMessage);

            } catch (e) {
                console.error("‚ùå Edit Message Error:", e);
            }
        });

        // --- 4.6 DELETE MESSAGE (NEW) ---
        socket.on('delete_message', async (data: { messageId: string, roomId: string }) => {
            const senderId = socket.data.userId;
            if (!senderId || !data.messageId) return;

            try {
                const existing = await prisma.message.findUnique({ where: { id: data.messageId } });
                if (!existing || existing.userId !== senderId) return;

                await prisma.message.delete({ where: { id: data.messageId } });

                io.to(data.roomId).emit('message_deleted', data.messageId);

            } catch (e) {
                console.error("‚ùå Delete Message Error:", e);
            }
        });

        // --- 5. START DM (ATOMIC FIND-OR-CREATE) ---
        socket.on('start_dm', async (targetUserId: string) => {
            const myId = socket.data.userId;
            if (!myId || !targetUserId) return;

            try {
                // 1. Check if DM Room already exists
                let room = await prisma.chatRoom.findFirst({
                    where: {
                        type: 'dm',
                        AND: [
                            { memberships: { some: { userId: myId } } },
                            { memberships: { some: { userId: targetUserId } } }
                        ]
                    },
                    include: {
                        memberships: { include: { user: true } },
                        messages: { take: 1, orderBy: { createdAt: 'desc' } }
                    }
                });

                // 2. If not, Create it
                if (!room) {
                    room = await prisma.chatRoom.create({
                        data: {
                            name: 'dm',
                            type: 'dm',
                            memberships: {
                                create: [
                                    { userId: myId, role: 'MEMBER' },
                                    { userId: targetUserId, role: 'MEMBER' }
                                ]
                            }
                        },
                        include: {
                            memberships: { include: { user: true } },
                            messages: { take: 1 }
                        }
                    });
                }

                // 3. Ensure both sockets join this room immediately
                socket.join(room.id); // Join sender
                
                // Find target socket if online
                const targetSocketEntry = Array.from(onlineUsers.entries()).find(([, u]) => u.userId === targetUserId);
                if (targetSocketEntry) {
                    const [targetSocketId] = targetSocketEntry;
                    const targetSocket = io.sockets.sockets.get(targetSocketId);
                    if (targetSocket) {
                        targetSocket.join(room.id);
                        // ‚úÖ FIX: Notify the target user so it appears in their sidebar immediately
                        targetSocket.emit('room_created', room);
                    }
                }

                // 4. Tell Sender "Here is your room" (and switch to it)
                socket.emit('open_dm', room);

            } catch (e) {
                console.error("‚ùå Start DM Error:", e);
            }
        });

        // --- 6. HISTORY ---
        socket.on('fetch_history', async (roomId: string) => {
            try {
                const history = await prisma.message.findMany({
                    where: { roomId },
                    take: 50,
                    orderBy: { createdAt: 'desc' },
                    include: {
                        user: { select: { id: true, name: true, avatar: true } },
                        reactions: { include: { user: { select: { id: true, name: true } } } },
                        _count: { select: { replies: true } }
                    }
                });
                socket.emit('history_loaded', { roomId, messages: history.reverse() });
            } catch (e) { console.error(e); }
        });

        // --- 7. CLEANUP ---
        socket.on('disconnect', () => {
            onlineUsers.delete(socket.id);
            io.emit('update_online_users', Array.from(onlineUsers.values()));
        });
    });
};

================================================
FILE: src/utils/supabase.ts
================================================
import { createClient } from '@supabase/supabase-js';
import fs from 'fs';
import path from 'path';

// --- CONFIGURATION ---
// Ensure these are in your .env file
const supabaseUrl = process.env.SUPABASE_URL || '';
const supabaseKey = process.env.SUPABASE_KEY || ''; // Use Service Role Key for better delete permissions if possible
const BUCKET_NAME = 'assets'; 

// Initialize Client
export const supabase = createClient(supabaseUrl, supabaseKey);

// ==========================================
// 1. UPLOAD FUNCTION
// ==========================================
export const uploadToSupabase = async (
  filePath: string, 
  destinationPath: string, 
  mimeType: string
): Promise<string> => {
  try {
    const fileContent = fs.readFileSync(filePath);

    // Upload file
    const { data, error } = await supabase.storage
      .from(BUCKET_NAME) 
      .upload(destinationPath, fileContent, {
        contentType: mimeType,
        upsert: true,
      });

    if (error) throw error;

    // Get Public URL
    const { data: publicData } = supabase.storage
      .from(BUCKET_NAME)
      .getPublicUrl(destinationPath);

    return publicData.publicUrl;
  } catch (error) {
    console.error('Supabase Upload Error:', error);
    throw new Error('Failed to upload to cloud storage');
  }
};

// ==========================================
// 2. DELETE FUNCTION (‚úÖ Added this)
// ==========================================
export const deleteFromSupabase = async (filePath: string): Promise<void> => {
  try {
    if (!filePath) return;

    // Helper: Extract relative path if the DB stores the full Public URL
    // e.g. "https://xyz.supabase.co/.../assets/folder/image.png" -> "folder/image.png"
    let pathClean = filePath;
    
    // If it is a full URL, strip the domain and bucket part
    if (filePath.startsWith('http')) {
        const urlParts = filePath.split(`${BUCKET_NAME}/`);
        if (urlParts.length > 1) {
            // Takes everything after "assets/"
            pathClean = urlParts.slice(1).join(`${BUCKET_NAME}/`); 
        }
    }

    // Perform Delete
    const { error } = await supabase.storage
      .from(BUCKET_NAME)
      .remove([pathClean]);

    if (error) {
      console.error(`Supabase Delete Error for ${pathClean}:`, error.message);
    } else {
      console.log(`üóëÔ∏è Deleted from Supabase: ${pathClean}`);
    }
  } catch (err) {
    console.error('Delete from Supabase failed:', err);
    // We do not throw here to prevent crashing the server/cron job 
    // if a file is already missing
  }
};

================================================
FILE: tsconfig.json
================================================
{
  "compilerOptions": {
    "target": "es2020",
    "module": "commonjs",
    "outDir": "./dist",
    "rootDir": "./src",
    "strict": true,
    "esModuleInterop": true,
    "skipLibCheck": true
  },
  "include": [
    "src/**/*"
  ],
  "exclude": [
    "node_modules",
    "scripts",
    "dist"
  ]
}
